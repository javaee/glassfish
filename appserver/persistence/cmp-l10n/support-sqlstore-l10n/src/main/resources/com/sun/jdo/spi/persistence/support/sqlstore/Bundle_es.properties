#
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
#
# Copyright (c) 1997-2017 Oracle and/or its affiliates. All rights reserved.
#
# The contents of this file are subject to the terms of either the GNU
# General Public License Version 2 only ("GPL") or the Common Development
# and Distribution License("CDDL") (collectively, the "License").  You
# may not use this file except in compliance with the License.  You can
# obtain a copy of the License at
# https://oss.oracle.com/licenses/CDDL+GPL-1.1
# or LICENSE.txt.  See the License for the specific
# language governing permissions and limitations under the License.
#
# When distributing the software, include this License Header Notice in each
# file and include the License file at LICENSE.txt.
#
# GPL Classpath Exception:
# Oracle designates this particular file as subject to the "Classpath"
# exception as provided by Oracle in the GPL Version 2 section of the License
# file that accompanied this code.
#
# Modifications:
# If applicable, add the following below the License Header, with the fields
# enclosed by brackets [] replaced by your own identifying information:
# "Portions Copyright [year] [name of copyright owner]"
#
# Contributor(s):
# If you wish your version of this file to be governed by only the CDDL or
# only the GPL Version 2, indicate your decision by adding "[Contributor]
# elects to include this software in this distribution under the [CDDL or GPL
# Version 2] license."  If you don't indicate a single choice of license, a
# recipient has the option to distribute your version of this file under
# either the CDDL, the GPL Version 2 or to extend the choice of license to
# its licensees as provided above.  However, if you add GPL Version 2 code
# and therefore, elected the GPL Version 2 license, then the option applies
# only if the new code is made subject to such option by the copyright
# holder.
#

# Resource bundle for sqlstore runtime messages
# key consists of: <subpackage>.<class>.<method>.<description>
# <subpackage> - is optional, package under runtime
# <class> - class name
# <method> - method name
# <description> - short description (use _ to represent space)
# all keys should be in lowercase
#
# Please note that many package names and classnames have changed over time.
# Unfortunately, this file was not maintained to follow above convention.
# Please ignore if the package/class name does not match actual names as today.
#
#
# The message ID for a message in persistence is derived as follows:
# JDO<2_digit_bundle_prefix><1_digit_section_number><2_digit_serial_number>
#
# The 2 digit prefix for this bundle is 76.
#
# This file is divided into the following sections:
# Under each section, messages that need not be I18Ned are separated under NOI18N. All other messages
# need to be numbered.
# 1. JDO:  PersistenceManagerFactory/PersistenceManager/ExtentCollection/LifeCycle
# 2. Model
# 3. StateManager
# 4. sql generator components: RetrieveDesc, ResultDesc plus all the files under generator subdir
# 5. SQLStoreManager
# 6. Connection/Connectionpool/Transaction/DBVendorType
# 7. EJB integration.
# 8. Generic messages.
#
# When adding a new message:
# 1. Please make sure that you add the message to the end of appropriate section.
# 2. Please add message ID to any user visible message.
# 3. The message ID for the new message = message ID for the last numbered
#    message in a section + 1.
# 4. Please do not change the message ID for existing messages. These
#    numbers are potentially mapped to more explanation about the message for
#    the end user.
#

####################################################################################################
# <All the source files under subdir impl (PersistenceManagerFactory/PersistenceManager etc.) >
# Message ID Range: JDO76000 - JDO76099
####################################################################################################
jdo.persistencemanagerfactoryimpl.getpersistencemanager.error=JDO76000: no se pueden utilizar varias combinaciones de nombre de usuario/contrase\u00F1a en la misma transacci\u00F3n.
jdo.persistencemanagerfactoryimpl.getpersistencemanager.notconfigured=JDO76001: PersistenceManagerFactory no est\u00E1 configurado.
jdo.persistencemanagerfactoryimpl.notsupported=JDO76002: no est\u00E1 soportada la operaci\u00F3n para PersistenceManagerFactoryImpl interno.
jdo.persistencemanagerimpl.acquireexclusivelock.interrupted=JDO76003: fallo al adquirir un bloqueo exclusivo debido a InterruptedException
jdo.persistencemanagerimpl.acquiresharelock.failed=JDO76004: fallo al adquirir un bloqueo compartido debido a que _readWriteCount es inferior a cero
jdo.persistencemanagerimpl.acquiresharelock.interrupted=JDO76005: fallo al adquirir un bloqueo compartido debido a InterruptedException
jdo.persistencemanagerimpl.another_pm=JDO76006: el objeto est\u00E1 asociado a otro PersistenceManager.
jdo.persistencemanagerimpl.assertactivetransaction.error=JDO76007: la transacci\u00F3n asociada a este gestor de persistencia no est\u00E1 activa.
jdo.persistencemanagerimpl.assertclosed.closed=JDO76008: PersistenceManager est\u00E1 cerrado.
jdo.persistencemanagerimpl.assertpersistencecapable.error=JDO76009: la clase {0} no se ha mejorado para la persistencia transparente. Use el empaquetador WAR o el JAR de IDE para empaquetar las clases compatibles con persistencia antes de ejecutarlas. O bien, defina la propiedad Ejecutor de la clase principal en Ejecutor de Persistencia para que se ejecute desde IDE.
jdo.persistencemanagerimpl.close.activetransaction=JDO76010: hay una transacci\u00F3n abierta asociada a este gestor de persistencia.
jdo.persistencemanagerimpl.fetchinstance.none=JDO76012: no se ha encontrado el objeto para este ObjectId.
jdo.persistencemanagerimpl.internaldeletepersistent.transient=JDO76014: no se puede suprimir el objeto no persistente.
jdo.persistencemanagerimpl.internalmakepersistent.dups=JDO76015: ya existe una instancia con la misma clave primaria en esta cach\u00E9 de PersistenceManager.
jdo.persistencemanagerimpl.loadclassforoid.wrongoidclass=JDO76016: error al recuperar la clase de objeto de OID.
jdo.persistencemanagerimpl.newscoinstance.wrongclass=JDO76017: no se puede crear la instancia SCO de la clase {0} porque no es un tipo v\u00E1lido.
jdo.persistencemanagerimpl.notprocessed=JDO76018: no se pueden vaciar instancias persistentes debido a dependencias circulares.
jdo.persistencemanagerimpl.releaseexclusivelock.failed=JDO76019: fallo al liberar un bloqueo exclusivo porque _readWriteCount es superior a cero
jdo.persistencemanagerimpl.releasesharelock.failed=JDO76020: fallo al liberar un bloqueo compartido porque _readWriteCount es igual a cero
jdo.persistencemanagerwrapper.invalidpm=JDO76021: PersistenceManagerWrapper est\u00E1 cerrado.
jdo.extentcollection.constructor.invalidclass=JDO76022: clase ''{0}'' no v\u00E1lida para la recopilaci\u00F3n de extensiones.
jdo.extentcollection.constructor.nonpc=JDO76023: la clase ''{0}'' no es compatible con persistencia.
jdo.extentcollection.constructor.subclasses=JDO76024: no est\u00E1 soportada la opci\u00F3n true de las subclases para las recopilaciones de extensiones.
jdo.extentcollection.illegalmodification=JDO76025: modificaci\u00F3n no v\u00E1lida de recopilaci\u00F3n de extensiones para la clase ''{0}''.
jdo.extentcollection.methodnotsupported=JDO76026: no est\u00E1 soportado el m\u00E9todo de recopilaci\u00F3n de extensiones {0}.
jdo.lifecycle.xactnotactive=JDO76027: se necesita una transacci\u00F3n activa para realizar esta operaci\u00F3n.
jdo.persistencemanagerimpl.newinstance.badsm=JDO76028: StateManager no est\u00E1 configurado en su totalidad.
jdo.persistencemanagerimpl.setjtatransaction.notnulljta=JDO76029: se ha intentado sustituir javax.transaction.Transaction no nulo: {0} por {1}.
jdo.persistencemanagerfactoryimpl.getpersistencemgr.closed=JDO76030: el valor PersistenceManager para este javax.transaction.Transaction: {0} ya se ha cerrado o confirmado.
jdo.persistencemanagerfactoryimpl.registerpm.registered=JDO76031: esta instancia de javax.transaction.Transaction: {0} ya se ha registrado con otro PersistenceManager: {1}.
jdo.persistencemanagerimpl.verificationfailed=JDO76032: la instancia de consistencia de versi\u00F3n no ha podido realizar la verificaci\u00F3n con el almac\u00E9n de datos.
jdo.persistencemanagerfactoryimpl.getversionconsistencycache.nullstore=JDO76033: StoreManager no est\u00E1 configurado.

#
# <NOI18N: LifeCycle>
#
sqlstore.state.lifecyclestate.changestate=LifeCycleState.changeState(), estado antiguo = {0}, nuevo estado = {1}.
sqlstore.state.lifecyclestate.initial=LifeCycleState.getLifeCycleState(), estado inicial = {0}.

#
# <NOI18N: PersistenceManager>
#
sqlstore.persistencemgr.acquireexclusivelock.count=acquireExclusiveLock(), thread {0} con _readWriteCount = {1}.
sqlstore.persistencemgr.acquireexclusivelock=acquireExclusiveock(), thread {0} cambiando a en espera.
sqlstore.persistencemgr.acquiresharedlock.rdwrcount=acquireShareLock(), thread {0} ha adquirido el bloqueo compartido con _readWriteCount ={1}.
sqlstore.persistencemgr.acquiresharedlock=acquireShareLock(), thread {0} cambiando a en espera.
sqlstore.persistencemgr.aftercompletion.process=---Proceso PersistenceManagerImpl.afterCompletion(): {0}.
sqlstore.persistencemgr.aftercompletion=---Aborto de PersistenceManagerImpl.afterCompletion(): {0}.
sqlstore.persistencemgr.assertactivetx.closed=--- PersistenceManagerImpl.assertActiveTransaction: Cerrado para {0}.
sqlstore.persistencemgr.assertactivetx=--- PersistenceManagerImpl.assertActiveTransaction: {0}.
sqlstore.persistencemgr.assertisopen=--- PersistenceManagerImpl.assertIsOpen: cerrado para {0}.
sqlstore.persistencemgr.beforecompletion=---PersistenceManagerImpl.beforeCompletion().
sqlstore.persistencemgr.cacheproperties=Propiedades de cach\u00E9 de PersistenceManagerImpl: _txCacheInitialCapacity={0}, _flushedCacheInitialCapacity={1}, _flushedCacheLoadFactor={2}, _weakCacheInitialCapacity={3}, _weakCacheLoadFactor={4}.
sqlstore.persistencemgr.deregisterinstance.verified=---PersistenceManagerImpl.deregisterInstance(): registro anulado con verify.
sqlstore.persistencemgr.deregisterinstance.verify=---PersistenceManagerImpl.deregisterInstance() with verify SM -- oid: {0}  for PersistenceManager: {1}  and JTA: {2}.
sqlstore.persistencemgr.deregisterinstance=---OID de PersistenceManagerImpl.deregisterInstance(): {0} para PersistenceManager: {1} y JTA: {2}.
sqlstore.persistencemgr.getbyobjid=---OID de PersistenceManagerImpl.getObjectById():{0} para PersistenceManager: {1} y JTA: {2}.
sqlstore.persistencemgr.getcurrentwrapper=---PersistenceManagerImpl.getCurrentWrapper() > actual: {0}.
sqlstore.persistencemgr.getobjid.notpc=---PersistenceManagerImpl.getObjectId() NOT PC: {0}  for PersistenceManager: {1}.
sqlstore.persistencemgr.getobjid.notpm=---PersistenceManagerImpl.getObjectId() NOT PM: {0} for PersistenceManager: {1}  and JTA: {2}.
sqlstore.persistencemgr.getobjid= :{0} ---PC de PersistenceManagerImpl.getObjectId(): {1} para PersistenceManager: {2} y JTA: {3}.
sqlstore.persistencemgr.internalcloneoid.old=---PersistenceManagerImpl.internalCloneOid(): antiguo: {0} nuevo: {1} mismo: {2}.
sqlstore.persistencemgr.internalcloneoid=---PersistenceManagerImpl.internalCloneOid(): error: {0}.
sqlstore.persistencemgr.isactivetx=---PersistenceManagerImpl.isActiveTransaction(): {0}.
sqlstore.persistencemgr.isnontxread=---PersistenceManagerImpl.isNontransactionalRead(): {0}.
sqlstore.persistencemgr.isoptimistic=---PersistenceManagerImpl.isOptimisticTransaction(): {0}.
sqlstore.persistencemgr.loadingclass=Cargando ... ClassName: {0}.
sqlstore.persistencemgr.loadingfile=Cargando ... FileName: {0} {1} {2}.
sqlstore.persistencemgr.makepersistent.done=---PersistenceManagerImpl.makePersistent() {0} terminado para: {1} y JTA: {2}.
sqlstore.persistencemgr.makepersistent= {0} ---PersistenceManagerImpl.makePersistent() PC: {1} para PersistenceManager: {2} y JTA: {3}.
sqlstore.persistencemgr.newcollection=---PersistenceManagerImpl.newCollectionInstanceInternal() tipo: {0}.
sqlstore.persistencemgr.popcurrentwrapper=---PersistenceManagerImpl.popCurrentWrapper() > actual: {0} anterior: {1}.
sqlstore.persistencemgr.pushcurrentwrapper=---PersistenceManagerImpl.pushCurrentWrapper() > actual: {0} nuevo: {1}.
sqlstore.persistencemgr.registerinstance= {0} ---PersistenceManagerImpl.registerInstance() oid/sm: {1}/{2} para PersistenceManager: {3} y JTA: {4}.
sqlstore.persistencemgr.registerinstancein_txc=registerInstance in TXC :{0} / {1} for PersistenceManager: {2} and JTA: {3}.
sqlstore.persistencemgr.registerinstancein_wkc=registerInstance in WKC.
sqlstore.persistencemgr.releaseexclusivelock=releaseExclusiveock(), thread {0} con _readWriteCount = {1}.
sqlstore.persistencemgr.releasesharedlock=releaseShareLock(), thread {0} con _readWriteCount = {1}.
sqlstore.persistencemgr.replacingdeletedinstance=Sustituyendo instancia suprimida con una nueva para el ID de objeto: {0}.
sqlstore.persistencemgr.setkeyfields=---PersistenceManagerImpl.setKeyFields(): error: {0}.
#
# <NOI18N: PersistenceManagerFactory>
#
sqlstore.sqlpersistencemgrfactory.getfrompool.pmt=<--SQLPersistenceManagerFactory.getFromPool() PM: {0} para JTA {1}.
sqlstore.sqlpersistencemgrfactory.getfrompool=<--SQLPersistenceManagerFactory.getFromPool().
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.found= {0} <->SQLPersistenceManagerFactory.getPersistenceManager() ha encontrado javax.transaction.Transaction: {1}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.jdotx.notfound=<->SQLPersistenceManagerFactory.getPersistenceManager() no ha encontrado la transacci\u00F3n de JDO.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.jdotx=<->SQLPersistenceManagerFactory.getPersistenceManager() Transacci\u00F3n de JDO: {0}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.pmclosedfor= {0} <->SQLPersistenceManagerFactory.getPersistenceManager() PM se ha cerrado para: {1}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.pmt= {0} <->SQLPersistenceManagerFactory.getPersistenceManager(): {1} para JTA: {2}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr=:{0} -->SQLPersistenceManagerFactory.getPersistenceManager().
sqlstore.sqlpersistencemgrfactory.init=---SQLPersistenceManagerFactory.initialize().
sqlstore.sqlpersistencemgrfactory.pmCacheBucketSize=---SQLPersistenceManagerFactory pmCacheBucketSize = {0}.
sqlstore.sqlpersistencemgrfactory.pmCacheInitialCapacity=---SQLPersistenceManagerFactory pmCacheInitialCapacity = {0}.
sqlstore.sqlpersistencemgrfactory.registerpersistencemgr.pmt=<->SQLPersistenceManagerFactory.registerPersistenceManager() PM: {0} for JTA Tx: {1}.
sqlstore.sqlpersistencemgrfactory.releasepm.pmt=---SQLPersistenceManagerFactory.releasePersistenceManager() PM:{0} para JTA Transacci\u00F3n: {1}.
sqlstore.sqlpersistencemgrfactory.returnToPool=<--SQLPersistenceManagerFactory.returnToPool().


###############################################################################
# <Model>
# Message ID Range: JDO76100 - JDO76199
###############################################################################
core.configuration.columnnotable=JDO76100: el descriptor de columna no incluye un descriptor de tabla v\u00E1lido.
core.configuration.fieldnotable=JDO76101: el campo {0} no est\u00E1 asociado a ninguna tabla.
core.configuration.fieldnotmapped=JDO76102: el campo persistente {0} de la clase {1} no est\u00E1 asignado.
core.configuration.iddescnofield=JDO76103: no se ha configurado correctamente el objeto SqlIDDesc. No hay ning\u00FAn descriptor de campo disponible.
core.configuration.loadfailed.class=JDO76104: no se ha podido cargar la configuraci\u00F3n de la clase {0}.
core.configuration.noneexistentpkfield=JDO76105: el campo {0} de la clase ObjectId {1} no existe en la clase PersistenceCapable {2}.
core.configuration.unsupportedconsistencylevel=JDO76106: la clase {0} tiene un nivel de consistencia no soportado. Los niveles de consistencia actualmente soportados son "none", "check-modified-at-commit", "lock-when-loaded" y "check-version-of-accessed-instances".
core.configuration.validationfailed=JDO76107: la asignaci\u00F3n de la clase {0} no es v\u00E1lida:\n{1}.
core.configuration.validationproblem=JDO76108: error de validaci\u00F3n de la clase {0}: {1}
#
# <FieldDesc validation at runtime>
#
core.fielddesc.minvalue=JDO76109: el valor {0} es inferior al m\u00EDnimo permitido, {1}, para el tipo de campo {2}.
core.fielddesc.maxvalue=JDO76110: El valor {0} es superior al m\u00E1ximo permitido, {1}, para el tipo de campo {2}.
core.configuration.noneexistentvcfield=JDO76111: el campo {0} se ha marcado como campo de versi\u00F3n, pero no existe en la clase PersistenceCapable {1}.
core.configuration.loadfailed.field=JDO76112: fallo al cargar la configuraci\u00F3n del campo {0} en la clase {1}.

#
# <NOI18N: model>
#
sqlstore.model.classdesc.assocrelatedfield=campo de relaci\u00F3n asociado = {0}.
sqlstore.model.classdesc.createsqldesc=creando SqlIDDesc de {0}.
sqlstore.model.classdesc.fieldinfo=nombre del campo = {0}, ID= {1}.
sqlstore.model.classdesc.general={0}.{1} =>{2}
sqlstore.model.classdesc.getlocalfielddesc=<-> SqlPersistenceDesc.getLocalFieldDesc(), clase ={0} campo oculto agregado {1} para la columna {2}.
sqlstore.model.classdesc.loadedclass=Clase de OID cargada correctamente = {0}.
sqlstore.model.classdesc.persistconfiginit.exit=<-- SqlPersistenceConfig.initialize().
sqlstore.model.classdesc.persistconfiginit=--> SqlPersistenceConfig.initialize(), clase = {0}.
sqlstore.model.classdesc.pkfield=Campo de clave primaria = {0}.
sqlstore.model.classdesc.primarytrackedfield=el campo {0} es el campo primario del seguimiento.
sqlstore.model.classdesc.unsetconcurrencychk=anulando definici\u00F3n de la propiedad IN_CONCURRENCY_CHECK para lf {0}.
sqlstore.model.classdesc.unsetrefintegrityupdate=anulando definici\u00F3n de la propiedad REF_INTEGRITY_UPDATES para ff {0}.
sqlstore.model.classdesc.vcfield=Campo de consistencia de la versi\u00F3n = {0}.
sqlstore.model.fielddesc.addingfield=agregando campo {0} para su seguimiento por parte del campo{1}.
sqlstore.model.fielddesc.convertvalue.from_to=convertValue: {0} De: {1} A: {2}.
sqlstore.model.fielddesc.convertvalue.hidden=convertValue: devuelve {0} ... oculto.
sqlstore.model.fielddesc.convertvalue=convertValue: devuelve NULL ...
sqlstore.model.fielddesc.fieldname={0} = {1}.
sqlstore.model.fielddesc.setupdesc=setupDesc(): fieldName {0} fieldType {1}.
sqlstore.model.configcacheimpl.size_before=tama\u00F1o de {0} antes de la limpieza: {1}.
sqlstore.model.configcacheimpl.size_after=tama\u00F1o de {0} despu\u00E9s de la limpieza: {1}.


###############################################################################
# <StateManager>
# Message ID Range: JDO76200 - JDO76299
###############################################################################
core.statemanager.anotherowner=JDO76200: no se puede asignar una instancia SCO que pertenezca a otro objeto.
core.statemanager.cantnewoid=JDO76201: fallo al crear una instancia de clave primaria nueva de la clase {0}.
core.statemanager.cantschedulejointable=JDO76202: fallo al programar la entrada de la tabla de uni\u00F3n entre la clase {0} y {1}, porque la descripci\u00F3n del campo de relaci\u00F3n es nula.
core.statemanager.cantsetkeyfield=JDO76203: fallo al definir el valor para el campo de clave primaria {0}.
core.statemanager.conflictingvalues=JDO76204: se ha producido un conflicto de valores entre el campo {0} y el campo {1} asignados a la misma columna
core.statemanager.getfieldfailed=JDO76205: fallo al obtener el campo.
core.statemanager.invalidpk=JDO76206: campo de clave primaria nulo {0} no v\u00E1lido al volver a cargar la instancia de la clase compatible con persistencia {1}. El ObjectId de la instancia es {2}.
core.statemanager.nopkupdate=JDO76207: no se permite la actualizaci\u00F3n de un campo de clave primaria.
core.statemanager.nopm=JDO76208: El gestor de estado no contiene una referencia al gestor de persistencia.
core.statemanager.notnavigable=JDO76209: se ha intentado acceder al campo {0} de la clase {1}. No se ha instanciado previamente este campo y esta clase no permite la navegaci\u00F3n din\u00E1mica. Debe solicitar el campo al recuperar la clase o permitir la navegaci\u00F3n din\u00E1mica para que se pueda recuperar autom\u00E1ticamente al acceder a \u00E9l.
core.statemanager.objectnotfound=JDO76210: el objeto no existe en el almac\u00E9n de datos.
core.statemanager.poshiddenindex=JDO76211: el \u00EDndice a un campo oculto deber\u00EDa ser negativo. Sin embargo, se ha obtenido un \u00EDndice {0}.
core.statemanager.readonly=JDO76212: se ha intentado modificar el campo de s\u00F3lo lectura {0} de la clase {1}.
core.statemanager.releaselock.wrongthread=JDO76213: este thread {0} no mantiene el bloqueo de StateManager.
core.statemanager.setfieldfailed=JDO76214: fallo al definir el campo.
core.statemanager.wrongusageforoverlappingpkfkdelete=JDO76215: Intento incorrecto de eliminar una instancia de una relaci\u00F3n gestionada. La relaci\u00F3n est\u00E1 definida por una columna de clave primaria del otro lado. Para realizar una operaci\u00F3n de eliminaci\u00F3n en una recopilaci\u00F3n, es necesario actualizar la columna del otro lado y no est\u00E1 permitido actualizar la clave primaria. Por lo tanto, s\u00F3lo se puede realizar la eliminaci\u00F3n de una instancia de una recopilaci\u00F3n de relaciones gestionadas definida por una clave primaria mediante la supresi\u00F3n de la instancia de forma expl\u00EDcita o en cascada.
core.statemanager.toomanyrows=JDO76215: se han devuelto varias filas para una de las tablas asignada a la clase {0}. Cada tabla asignada a una clase deber\u00EDa tener s\u00F3lo una fila por cada instancia del objeto.
core.statemanager.copyFields.mismatch=JDO76216: se ha intentado copiar los campos de un StateManager a otro que est\u00E1 gestionando instancias de diferentes tipos: {0} y {1}.

#
# <NOI18N: StateManager>
#
sqlstore.sqlstatemanager.adddependency=<-> SQLStateManager.addDependency(), este StateManager: {0}, otro StateManager: {1}.
sqlstore.sqlstatemanager.addupdate=<-> SQLStateManager.addUpdatedForeignReference(), lobj={0}, f={1}, fobj={2}, refCount={3}.
sqlstore.sqlstatemanager.applyupdates.exit=<-- SqlStateManager.applyUpdates().
sqlstore.sqlstatemanager.applyupdates=--> SqlStateManager.applyUpdates(), campo = {0}.
sqlstore.sqlstatemanager.clearpersistencefields.exit=<--- SqlStateManager.clearPersistenceFields().
sqlstore.sqlstatemanager.clearpersistencefields=--> SqlStateManager.clearPersistenceFields().
sqlstore.sqlstatemanager.copychanges.exit=<-- SQLStateManager.copyChanges().
sqlstore.sqlstatemanager.copychanges=--> SQLStateManager.copyChanges(), gestor de estado = {0}.
sqlstore.sqlstatemanager.deletepersistence=<-> SqlStateManager.deletePersistence(), tipo = {0}.
sqlstore.sqlstatemanager.getbeforeimage.exit=<-- SqlStateManager.getBeforeImage().
sqlstore.sqlstatemanager.getbeforeimage=--> SqlStateManager.getBeforeImage(), tipo = {0}.
sqlstore.sqlstatemanager.isbeforeimagerequired=isBeforeImageRequired es: {0}.
sqlstore.sqlstatemanager.loadforread.exit=<-- SQLStateManager.loadForRead().
sqlstore.sqlstatemanager.loadforread=--> SQLStateManager.loadForRead().
sqlstore.sqlstatemanager.loadforupdate.exit=<-- SQLStateManager.loadForUpdate().
sqlstore.sqlstatemanager.loadforupdate=--> SQLStateManager.loadForUpdate().
sqlstore.sqlstatemanager.loggingfield=registrando campo = {0} con el valor = {1}.
sqlstore.sqlstatemanager.makedirty.fixscocollection=--- SqlStateManager.makeDirty(), fix SCOCollection.
sqlstore.sqlstatemanager.makedirty.fixscodate=--- SqlStateManager.makeDirty(), fix SCODate.
sqlstore.sqlstatemanager.makedirty=--> SqlStateManager.makeDirty(), campo = {0}.
sqlstore.sqlstatemanager.makedirtyfield=Campo sucio marcado = {0}.
sqlstore.sqlstatemanager.makepersistence=<-> SqlStateManager.makePersistence(), tipo = {0}.
sqlstore.sqlstatemanager.makepresent=--> SqlStateManager.makePresent(), campo = {0}.
sqlstore.sqlstatemanager.marking=marcando: {0} como presente.
sqlstore.sqlstatemanager.newtype=Nuevo Tipo: {0}.
sqlstore.sqlstatemanager.nosuchmethodexcep.clone=Excepci\u00F3n: clon de {0} ... para el tipo {1}.
sqlstore.sqlstatemanager.preparegetfield.exit=<-- SqlStateManager.prepareGetField().
sqlstore.sqlstatemanager.preparegetfield=--> SqlStateManager.prepareGetField(), nombre = {0}.
sqlstore.sqlstatemanager.preparesetfield.exit=<-- SQLStateManager.prepareSetField().
sqlstore.sqlstatemanager.preparesetfield=--> SQLStateManager.prepareSetField(), nombre = {0}.
sqlstore.sqlstatemanager.preparetoupdateph1.exit=<-- SqlStateManager.prepareToUpdateI().
sqlstore.sqlstatemanager.preparetoupdateph1=--> SqlStateManager.prepareToUpdatePhaseI(), tipo = {0}.
sqlstore.sqlstatemanager.preparetoupdateph2.exit=<-- SqlStateManager.prepareToUpdateII().
sqlstore.sqlstatemanager.preparetoupdateph2=--> SqlStateManager.prepareToUpdatePhaseII(), tipo = {0}.
sqlstore.sqlstatemanager.preparetoupdateph3.exit=<-- SqlStateManager.prepareToUpdateIII().
sqlstore.sqlstatemanager.preparetoupdateph3=--> SqlStateManager.prepareToUpdatePhaseIII(), tipo = {0}.
sqlstore.sqlstatemanager.prepareupdatefield.exit=<-- SQLStateManager.prepareUpdateField().
sqlstore.sqlstatemanager.prepareupdatefield=--> SQLStateManager.prepareUpdateField(), nombre = {0} para el estado: {1}.
sqlstore.sqlstatemanager.prepareupdatefieldspl.exit=<-- SQLStateManager.prepareUpdateFieldSpecial().
sqlstore.sqlstatemanager.prepareupdatefieldspl=--> SQLStateManager.prepareUpdateFieldSpecial, nombre = {0} para el estado: {1}.
sqlstore.sqlstatemanager.processcollectionupdate.exit=<-- SQLStateManager.processCollectionUpdates().
sqlstore.sqlstatemanager.processcollectionupdate=--> SQLStateManager.processCollectionUpdates(), beforeList={0}, afterlist={1}.
sqlstore.sqlstatemanager.processforeign=procesar campo ajeno = {0}.
sqlstore.sqlstatemanager.processforeignfield.remove=-- SQLStateManager.processForeignField(): era Collection - eliminar.
sqlstore.sqlstatemanager.processforeignfield.remove_from_bi=-- SQLStateManager.processForeignField(): es SCOCollection - eliminar de BI.
sqlstore.sqlstatemanager.processforeignfield.reset=-- SQLStateManager.processForeignField(): era SCOCollection - restablecer.
sqlstore.sqlstatemanager.processforeignfield=-- SQLStateManager.processForeignField(): valor: {0} tipo: {1}.
sqlstore.sqlstatemanager.realizefield.exit=<-- SqlStateManager.realizeField().
sqlstore.sqlstatemanager.realizefield=--> SqlStateManager.realizeField(), nombre = {0}.
sqlstore.sqlstatemanager.realizeforeignfield.exit=<-- SqlStateManager.realizeField(), campo detectado = {0}.
sqlstore.sqlstatemanager.realizeforeignfield=--> SqlStateManager.realizeField(), nombre = {0}.
sqlstore.sqlstatemanager.recordingfield=grabando campo = {0}.
sqlstore.sqlstatemanager.refreshpersistent.exit=<-- SqlStateManager.refreshPersistent().
sqlstore.sqlstatemanager.refreshpersistent=--> SqlStateManager.refreshPersistence(), tipo = {0}.
sqlstore.sqlstatemanager.reload.exit=<-- SqlStateManager.reload(FieldDesc).
sqlstore.sqlstatemanager.reload=--> SqlStateManager.reload(FieldDesc), tipo = {0}, campo = {1}.
sqlstore.sqlstatemanager.removeupdate=<-> SQLStateManager.removeUpdatedForeignReference(), lobj={0}, f={1}, fobj={2}, refCount={3}.
sqlstore.sqlstatemanager.replaceobjectfield.unsetsco=-- SqlStateManager.replaceObjectField(), anular definici\u00F3n de SCO.
sqlstore.sqlstatemanager.replaceobjectfield=-- SqlStateManager.replaceObjectField(), campo = {0}, tipo = {1}.
sqlstore.sqlstatemanager.reset=--> SqlStateManager.reset(), retValues = {0}, wasNew: {1}, keepState: {2}.
sqlstore.sqlstatemanager.resettingcollection=Restableciendo recopilaci\u00F3n.
sqlstore.sqlstatemanager.resettingdate=Restableciendo fecha.
sqlstore.sqlstatemanager.resolvedependencies=<-> SQLStateManager.resolveDependencies(), obj={0}.
sqlstore.sqlstatemanager.resolvedependency=<-> SQLStateManager.resolveDependency(), dependencia resuelta: lobj={0}, f={1}, fobj={2}.
sqlstore.sqlstatemanager.retrieve.exit=<-- SqlStateManager.retrieve().
sqlstore.sqlstatemanager.retrieve=--> SqlStateManager.retrieve(), nombre = {0}.
sqlstore.sqlstatemanager.retrieveforeign.exit=<-- SqlStateManager.retrieveForeign().
sqlstore.sqlstatemanager.retrieveforeign=--> SqlStateManager.retrieveForeign(), nombre = {0}.
sqlstore.sqlstatemanager.unsetmask=anulando definici\u00F3n de m\u00E1scaras para el campo = {0}.
sqlstore.sqlstatemanager.unconditionalreload.exit=<-- SqlStateManager.reload().
sqlstore.sqlstatemanager.unconditionalreload=--> SqlStateManager.reload(), tipo = {0}.
sqlstore.sqlstatemanager.updatebeforeimage=<-> SQLStateManager.updateBeforeImage(), nombre = {0}, valor = {1}.
sqlstore.sqlstatemanager.updateobjfield.exit=<-- SQLStateManager.updateObjectField().
sqlstore.sqlstatemanager.updateobjfield=--> SQLStateManager.updateObjectField(), nombre = {0}, tipo = {1}.
sqlstore.sqlstatemanager.updatepersistent.exit=<-- SqlStateManager.updatePersistent().
sqlstore.sqlstatemanager.updatepersistent.immediateflush=<--> SqlStateManager.updatePersistent(), vaciado inmediato necesario: obj={0}, siguiente ={1}.
sqlstore.sqlstatemanager.updatepersistent.skipped=<--> SqlStateManager.updatePersistent() omitido, tipo = {0}, obj = {1}.
sqlstore.sqlstatemanager.updatepersistent=--> SqlStateManager.updatePersistent(), tipo = {0}.
sqlstore.sqlstatemanager.updatetrackedfields.exit=<-- updateTrackedFields().
sqlstore.sqlstatemanager.updatetrackedfields=--> updateTrackedFields(), f = {0} valor = {1}  fieldToIgnore = {2}.


###############################################################################
# <sql generator components: All the source files under sql.>
# Message ID Range: JDO76300 - JDO76399
###############################################################################
core.constraint.duporderby=JDO76300: esta restricci\u00F3n es una propiedad \\"order by\\" para el campo {0} que ya se ha especificado en la restricci\u00F3n \\"order by\\".
core.constraint.fielddisallowed=JDO76301: se ha especificado el par\u00E1metro fieldName, pero no se permite con la operaci\u00F3n {0}.
core.constraint.fieldrequired=JDO76302: falta el par\u00E1metro fieldName. La operaci\u00F3n {0} necesita un campo.
core.constraint.illegalParameterInfo=JDO76303: se debe llamar a addConstraint() de OP_PARAMETER con el tipo de valor ParameterInfo.
core.constraint.illegalnode=JDO76304: nodo de restricci\u00F3n no v\u00E1lido {0} en la pila SqlConstraint.
core.constraint.illegalop=JDO76305: el par\u00E1metro de operaci\u00F3n contiene un valor {0} no v\u00E1lido.
core.constraint.needfieldnamenode=JDO76306: error en la pila de restricciones. Se esperaba un nombre de campo.
core.constraint.needfieldnode=JDO76307: error en la pila de restricciones. Se esperaba una descripci\u00F3n de campo.
core.constraint.needvalnode=JDO76308: error en la pila de restricciones. Se esperaba un valor.
core.constraint.stackempty=JDO76309: la pila de restricciones est\u00E1 vac\u00EDa. No hay suficientes valores para el n\u00FAmero del operador.
core.constraint.unknownfield=JDO76310: el campo {0} especificado en el descriptor de recuperaci\u00F3n no es miembro de la clase {1}.
core.constraint.valdisallowed=JDO76311: se ha especificado el par\u00E1metro del valor, pero no se permite con la operaci\u00F3n {0}.
core.constraint.valrequired=JDO76312: falta el par\u00E1metro del valor. La operaci\u00F3n {0} necesita un valor.
sqlstore.resultdesc.errorgettingvalefromresulset=JDO76313: error al obtener el valor de resultset en el \u00EDndice {0} como resultType {1}. columnSqlType {2}. Excepci\u00F3n: {3}
sqlstore.resultdesc.foreignfieldprojection=JDO76314: la consultas de {0} no deber\u00EDa tener proyecciones en un campo de relaci\u00F3n.
sqlstore.resultdesc.unknownfieldtype=JDO76317: se ha encontrado un tipo de campo desconocido {0}.
sqlstore.retrievedesc.toomanyprojections=JDO76318: no se pueden definir varias proyecciones para RetrieveDesc.
sqlstore.retrievedesc.toomanyresulttypes=JDO76319: no se pueden definir varios tipos de resultados para RetrieveDesc.
sqlstore.selectstatement.noupdatelocksupport=JDO76320: uno de los tipos de objetos relacionado con esta consulta tiene un nivel de consistencia "lock-when-loaded". Para aplicar este nivel de consistencia, es necesario que el almac\u00E9n de datos soporte el bloqueo de actualizaci\u00F3n por filas. El almac\u00E9n de datos no soporta el bloqueo de actualizaci\u00F3n por filas.
sqlstore.sql.generator.statement.likeescapenotsupported=JDO76321: la cl\u00E1usula LIKE ESCAPE no est\u00E1 soportada en esta base de datos.
sqlstore.sql.generator.statement.positionthreeargsnotsupported=JDO76322: el tercer arg para la cl\u00E1usula POSITION debe ser 1.
core.configuration.classnotmapped=JDO76323: la clase {0} no se ha asignado.
core.configuration.classnotmappedtotable=JDO76324: la clase {0} no est\u00E1 asignada a la tabla {1}.
sqlstore.sql.generator.statement.unexpectedconstraint=JDO76325: una restricci\u00F3n para la operaci\u00F3n {0} no puede ser nunca el elemento ra\u00EDz de una cl\u00E1usula WHERE.

# <I18N: sql generator>
# Following messages are used within other messages. They need to be i18ned but need not be numbered.
#
sqlstore.sql.generator.statement.sqlStatement=Sentencia SQL
sqlstore.sql.generator.statement.withinputvalues= valores de entrada:
sqlstore.sql.generator.statement.withnoinputvalues= ning\u00FAn valor de entrada.


#
# <ResultDesc NOI18N>
#
sqlstore.resultdesc.deserializing=deserializando = {0}.
sqlstore.resultdesc.marking_field=marcando campo local {0} como presente.
sqlstore.resultdesc.marking_foreign_field=marcando campo ajeno {0} como presente.
sqlstore.resultdesc.marking_key_field=marcando campo de clave {0} como presente.
sqlstore.resultdesc.returning_field=devolviendo campo {0} como proyecci\u00F3n.
#
# <Misc. SQLStore NOI18N >
#
sqlstore.sql.concurrency.concurrencychkdirty.exit=--> ConcurrencyCheckDirty.update().
sqlstore.sql.concurrency.concurrencychkdirty=--> ConcurrencyCheckDirty.update(), beforeImage = {0}.
sqlstore.sql.concurrencyoptverify.resumetx=<--> ConcurrencyOptVerify.resume(), transacci\u00F3n reanudada = {0}.
sqlstore.sql.concurrencyoptverify.suspendtx=<--> ConcurrencyOptVerify.suspend(), transacci\u00F3n suspendida = {0}.
sqlstore.sql.concurrencyoptverify.update.exit=<-- ConcurrencyOptVerify.update().
sqlstore.sql.concurrencyoptverify.update=--> ConcurrencyOptVerify.update(), beforeImage = {0}.
sqlstore.sql.generator.dbstatement.addbatch=addbatch ({0})
sqlstore.sql.generator.dbstatement.bindinputcolumn=\u00EDndice de bindInputColumn: {0} valor: {1} sqlType: {2}.
sqlstore.sql.generator.dbstatement.executebatch=executeBatch ejecutando {0} comandos
sqlstore.sql.generator.selectqueryplan.processforeignfield.exit=<-- SelectQueryPlan.processForeignFields().
sqlstore.sql.generator.selectqueryplan.processforeignfield=--> SelectQueryPlan.processForeignFields(), clase = {0}.
sqlstore.sql.generator.selectqueryplan.processlocalfield.exit=<-- SelectQueryPlan.processLocalFields().
sqlstore.sql.generator.selectqueryplan.processlocalfield=--> SelectQueryPlan.processLocalFields(), clase = {0}.
sqlstore.sql.generator.selectqueryplan.processstmts.exit=<-- SelectQueryPlan.processStatements().
sqlstore.sql.generator.selectqueryplan.processstmts=--> SelectQueryPlan.processStatements(), clase = {0}, sentencias = {1}.
sqlstore.sql.updateobjdescimpl.afterimagenull=AfterImage no se ha definido.
sqlstore.sql.updateobjdescimpl.beforeimagenull=BeforeImage no se ha definido.
sqlstore.sql.updateobjdescimpl.markrelationshipchange=<--> UpdateDesc.markRelationshipChange().
sqlstore.sql.updateobjdescimpl.updated={0} se ha actualizado.


###############################################################################
# <SQLStoreManager>
# Message ID Range: JDO76400 - JDO76499
###############################################################################
#
# <SQLStoreManager>
#
core.persistencestore.jdbcerror=JDO76400: se ha obtenido una excepci\u00F3n SQLException de JDBC al ejecutar la sentencia SQL:\n{0}.\nExamine la excepci\u00F3n SQLException para obtener m\u00E1s informaci\u00F3n.
sqlstore.retrievedesc.stmntsnotjoined=JDO76401: varias sentencias SQL no soportadas para un RetrieveDesc.
core.persistencestore.toofewrows=JDO76402: se han devuelto menos filas de la base de datos que las que permite la cardinalidad de esta asociaci\u00F3n al intentar obtener el valor de la asociaci\u00F3n {1} de la clase {0}. El n\u00FAmero m\u00EDnimo de filas permitido es {2}.
core.persistencestore.toomanyobjforcard1=JDO76403: la base de datos no es consistente con el modelo persistente. Se ha intentado recuperar el objeto correspondiente a la asociaci\u00F3n {1} de los elementos recuperados {2} de la clase {0}, pero s\u00F3lo se puede incluir 1 elemento, ya que el l\u00EDmite superior de cardinalidad es 1.
core.persistencestore.toomanyrows=JDO76405: se han devuelto m\u00E1s filas de la base de datos que las que permite la cardinalidad de esta asociaci\u00F3n al intentar obtener el valor de la asociaci\u00F3n {1} de la clase {0}. El n\u00FAmero m\u00E1ximo de filas permitido es {2}.
core.store.concurrentaccess=JDO76406: excepci\u00F3n de acceso simult\u00E1neo: otra transacci\u00F3n ha actualizado o suprimido el objeto para {0}.
sqlstore.sqlstoremanager.errorcloseresultset=JDO76407: error al cerrar el juego de resultados SQL. Excepci\u00F3n: {0}
sqlstore.sqlstoremanager.errorclosestatement=JDO76408: error al cerrar la sentencia SQL. Excepci\u00F3n: {0}
sqlstore.sql.generator.selectqueryplan.plansnotjoined=JDO76409: varios planes de consulta no soportados para un RetrieveDesc.

#
# <NOI18N: SQLStoreManager>
#
sqlstore.sqlstoremanager.executeQuery.exit=<-- SQLStoreManager.executeQuery().
sqlstore.sqlstoremanager.executeQuery=--> SQLStoreManager.executeQuery().
sqlstore.sqlstoremanager.executeupdate.exit=<-- SQLStoreManager.executeUpdate(), filas afectadas = {0}.
sqlstore.sqlstoremanager.executeupdate=--> SQLStoreManager.executeUpdate().
sqlstore.sqlstoremanager.executeupdatebatch.addbatch={0}; agregar lote.
sqlstore.sqlstoremanager.executeupdatebatch.exit=<-- SQLStoreManager.executeUpdateBatch().
sqlstore.sqlstoremanager.executeupdatebatch.exit.flush=<-- SQLStoreManager.executeUpdateBatch(), filas afectadas = {0}.
sqlstore.sqlstoremanager.executeupdatebatch.flushbatch={0}; vaciar lote.
sqlstore.sqlstoremanager.executeupdatebatch=--> SQLStoreManager.executeUpdateBatch().
sqlstore.sqlstoremanager.getpersistenceconfig=<--> SQLStoreManager.getPersistenceConfig(), classType = {0}.
sqlstore.sqlstoremanager.selectnoncorrelated.exit=<-- SQLStoreManager.selectNonCorrelated().
sqlstore.sqlstoremanager.selectnoncorrelated=--> SQLStoreManager.selectNonCorrelated().
sqlstore.sqlstoremanager.vendortype=<--> SQLStoreManager: tipo de proveedor = {0}.


###############################################################################
# <Connection/Connectionpool/DBVendorType/TransactionImpl/OracleSpecialDBOperation>
# Message ID Range: JDO76500 - JDO76599
###############################################################################
#
# <Connection/Connection Pool> - database
#
connection.connectionmanager.badnew=JDO76500: ''{0}'' nuevo debe ser superior o igual a ''{1}'' actual.
connection.connectionmanager.badvalue=JDO76501: valor no v\u00E1lido para ''{0}''.
connection.connectionmanager.conntimeout=JDO76502: el timeout de la conexi\u00F3n ha caducado.
connection.connectionmanager.getconnection.mismatch=JDO76503: la conexi\u00F3n de pool no tiene el mismo contexto de usuario.
connection.connectionmanager.isdown=JDO76504: se est\u00E1 cerrando el gestor de conexiones.
connection.connectionmanager.maxpool=JDO76505: el pool de conexiones est\u00E1 en su capacidad m\u00E1xima.
connection.connectionmanager.msintervalvalue=JDO76506: MsInterval debe ser mayor que cero y menor o igual que MsWait.
connection.connectionmanager.mswaitvalue=JDO76507: MsWait debe ser mayor o igual que cero.
connection.connectionmanager.nulldriver=JDO76508: valor NULL para el nombre de controlador.
connection.connectionmanager.nullurl=JDO76509: valor NULL para URL.
connection.connectionmanager.poolsize=JDO76510: 'maxPool' debe ser mayor o igual que 'minPool'.
connection.connectionmanager.threaditerupted=JDO76511: thread interrumpido.
connection.connectionmanager.zero=JDO76512: ''{0}'' debe ser mayor o igual que cero.
#
# <DBVendorType>
#
sqlstore.database.dbvendor.cantloadDefaultProperties=JDO76513: no se pueden cargar las propiedades de la base de datos por defecto.
sqlstore.database.dbvendor.init.default=JDO76514: -->No se ha podido cargar la propiedad de tipo de proveedor {0}. Se utilizar\u00E1n los valores por defecto.
sqlstore.database.dbvendor.cantinstantiateclass=JDO76515: fallo al instanciar la clase {0}.
#
# <OracleSpecialDBOperation>
#
sqlstore.database.oracle.defineCol=JDO76516: fallo al definir la columna para la sentencia.
sqlstore.database.oracle.nooracleavailable=JDO76517: al inicializar la f\u00E1brica de recursos de Oracle ''{0}'', se ha producido un fallo al obtener una instancia de oracle.jdbc.OraclePreparedStatement u oracle.jdbc.driver.OraclePreparedStatement. Se desactivar\u00E1 la optimizaci\u00F3n espec\u00EDfica de Oracle. Si las instancias que utilizan este recurso necesitan valores de enlace para las columnas asignadas a la columna de caracteres fijos, los valores se rellenar\u00E1n con espacios hasta la longitud especificada en el archivo dbschema correspondiente.
sqlstore.database.oracle.fixedcharpadded=JDO76518: el valor "{0}" est\u00E1 enlazado a una columna CHAR. En Oracle, esto se debe tratar de forma especial. Debido a que la clase OraclePreparedStatement no se ha podido obtener del controlador, el valor se rellenar\u00E1 con espacios hasta la longitud {1}, tal y como se especifica en el archivo dbschema capturado.
#
# <Misc.>
#
core.configuration.getvendortypefailed=JDO76519: fallo al identificar el tipo de proveedor para el almac\u00E9n de datos.
jdo.sqlpersistencemanagerfactory.errorgettingDatabaseInfo=JDO76520: errores al obtener la informaci\u00F3n sobre la base de datos. Se ha obtenido la siguiente excepci\u00F3n:

#
# <NOI18N: Connection>
#
sqlstore.connection.conncectiomgr.found=<--> ConnectionManager.getConnection: se ha encontrado {0}.
sqlstore.connection.conncectiomgr.getnewconn=<--> ConnectionManager.getConnection: nueva {0}.
sqlstore.connection.conncectiomgr.replacefreeconn=<--> ConnectionManager.replaceFreeConnection: libre {0}.
sqlstore.connectionimpl.clearxact.close=--- ConnectionImpl.clearXact: conexi\u00F3n cerrada.
sqlstore.connectionimpl.clearxact.disassocxact=--- ConnectionImpl.clearXact: disassociateXact .
sqlstore.connectionimpl.clearxact=--- ConnectionImpl.clearXact: .
sqlstore.connectionimpl.close.connrelease=<--- ConnectionImpl.close: conexi\u00F3n liberada.
sqlstore.connectionimpl.close.exit=<--- ConnectionImpl.close: conexi\u00F3n cerrada.
sqlstore.connectionimpl.close.freepending=<--- ConnectionImpl.close: definir FreePending.
sqlstore.connectionimpl.close.putfreelist=<--- ConnectionImpl.close: incluir en freeList.
sqlstore.connectionimpl.close.replaced=<--- ConnectionImpl.close: conexi\u00F3n sustituida.
sqlstore.connectionimpl.close=---> ConnectionImpl.close.
sqlstore.connectionimpl.close_arg=---> ConnectionImpl.close: {0}.
sqlstore.connectionimpl.commit=--- ConnectionImpl.commit: conexi\u00F3n cerrada.
sqlstore.connectionimpl.finalize=--- ConnectionImpl.finalize: conexi\u00F3n cerrada.
sqlstore.connectionimpl.internalcommit=--- ConnectionImpl.internalCommit: .
sqlstore.connectionimpl.pendingdisassocxact=--- ConnectionImpl.clearXact: Pending disassociateXact.
sqlstore.connectionimpl.rollback.close=--- ConnectionImpl.rollback: conexi\u00F3n cerrada.
sqlstore.connectionimpl.rollback=--- ConnectionImpl.rollback:.
#
# <NOI18N: DBVendorType>
#
sqlstore.database.dbvendor.castRequiredForNumericValues=<-> DBVendorType.isCastRequiredForNumericValues(): {0}.
sqlstore.database.dbvendor.getModFunctionName=<-> DBVendorType.getModFunctionName(): {0}.
sqlstore.database.dbvendor.getNullComparisonFunctionName=<-> DBVendorType.getNullComparisonFunctionName(): {0}.
sqlstore.database.dbvendor.getConcatCast=<-> DBVendorType.getConcatCast(): {0}.
sqlstore.database.dbvendor.getSpecialDBOperation=<-> DBVendorType.getSpecialDBOperation(): {0}.
sqlstore.database.dbvendor.getabs=<-> DBVendorType.getAbs(): {0}.
sqlstore.database.dbvendor.getcharlength=<-> DBVendorType.getCharLength(): {0}.
sqlstore.database.dbvendor.getforupdate=<-> DBVendorType.getForUpdate(): {0}.
sqlstore.database.dbvendor.getholdlock=<-> DBVendorType.getHoldlock(): {0}.
sqlstore.database.dbvendor.getisnotnull=<-> DBVendorType.getIsNotNull(): {0}.
sqlstore.database.dbvendor.getisnull=<-> DBVendorType.getIsNull(): {0}.
sqlstore.database.dbvendor.getleftjoin=<-> DBVendorType.getLeftJoin(): {0}.
sqlstore.database.dbvendor.getleftjoinpost=<-> DBVendorType.getLeftJoinPost(): {0}.
sqlstore.database.dbvendor.getleftlikeescape=<-> DBVendorType.getLeftLikeEscape(): {0}.
sqlstore.database.dbvendor.getnotequal=<-> DBVendorType.getNotEqual(): {0}.
sqlstore.database.dbvendor.getposition3args=<-> DBVendorType.getPositionThreeArrgs(): {0}.
sqlstore.database.dbvendor.getposition=<-> DBVendorType.getPosition(): {0}.
sqlstore.database.dbvendor.getpositionin=<-> DBVendorType.getPositionIn(): {0}.
sqlstore.database.dbvendor.getpositionsrchsrc=<-> DBVendorType.getPositionSearchSource(): {0}.
sqlstore.database.dbvendor.getquotecharstart=<-> DBVendorType.getQuoteCharStart(): {0}.
sqlstore.database.dbvendor.getrightjoinipre=<-> DBVendorType.getRightJoin(): {0}.
sqlstore.database.dbvendor.getrightlikeescape=<-> DBVendorType.getRightLikeEscape(): {0}.
sqlstore.database.dbvendor.getrtrim=<-> DBVendorType.getRtrim(): {0}.
sqlstore.database.dbvendor.getrtrimpost=<-> DBVendorType.getRtrimPost(): {0}.
sqlstore.database.dbvendor.getsqrt=<-> DBVendorType.getSqrt(): {0}.
sqlstore.database.dbvendor.getstringconcat=<-> DBVendorType.getStringConcat(): {0}.
sqlstore.database.dbvendor.getsubstring=<-> DBVendorType.getSubstring(): {0}.
sqlstore.database.dbvendor.getsubstringfor=<-> DBVendorType.getSubstringFor(): {0}.
sqlstore.database.dbvendor.getsubstringfrom=<-> DBVendorType.getSubstringFrom(): {0}.
sqlstore.database.dbvendor.gettablelistend=<-> DBVendorType.getTableListEnd(): {0}.
sqlstore.database.dbvendor.gettableliststart=<-> DBVendorType.getTableListStart(): {0}.
sqlstore.database.dbvendor.isAnsiTrim=<-> DBVendorType.isAnsiTrim(): {0}.
sqlstore.database.dbvendor.isInlineNumeric=<-> DBVendorType.isInlineNumeric(): {0}.
sqlstore.database.dbvendor.isNativeOuterJoin=<-> DBVendorType.isNativeOuterJoin(): {0}.
sqlstore.database.dbvendor.isParameterCast=<-> DBVendorType.isParameterCast(): {0}.
sqlstore.database.dbvendor.isdistinctupdatelocksupported=<-> DBVendorType.isDistinctSupportedWithUpdateLock(): {0}.
sqlstore.database.dbvendor.islockcolumnlistsupported=<-> DBVendorType.isLockColumnListSupported(): {0}.
sqlstore.database.dbvendor.isupdatelocksupported=<-> DBVendorType.isUpdateLockSupported(): {0}.
sqlstore.database.dbvendor.mapemptystrtonull=<-> DBVendorType.mapEmptyStringToNull(): {0}.
sqlstore.database.dbvendor.overrideproperties.with=<-> DBVendorType.overrideProperties() : {0} con: {1}.
sqlstore.database.dbvendor.overrideproperties=<-> DBVendorType.overrideProperties() - NONE.
sqlstore.database.dbvendor.supportslikeescape=<-> DBVendorType.supportsLikeEscape(): {0}.
sqlstore.database.dbvendor.vendorname=<-> DBVendorType(), vendorName: [{0}]  vendorType: {1}.
#
# <NOI18N: TransactionImpl>
#
sqlstore.transactionimpl.call.info={0} Tran[ {1} ].{2}: {3} para {4}.
sqlstore.transactionimpl.call={0} Tran[ {1} ].{2}:status = {3}, txType: {4} for  {5}.
sqlstore.transactionimpl.closeconnection=--- TransactionImpl.closeConnection() {0} para {1}.
sqlstore.transactionimpl.general={0}.
sqlstore.transactionimpl.getconnection=--- TransactionImpl.getConnection(): {0} Transacci\u00F3n optimista: {1} referenceCount = {2} para {3}.
sqlstore.transactionimpl.releaseconnection=--- TransactionImpl.releaseConnection(): Transacci\u00F3n optimista: {0} Dentro de Confirmaci\u00F3n: {1} referenceCount: {2} para {3}.
sqlstore.transactionimpl.rollbackconnection=--- TransactionImpl.rollbackConnection(): {0} para {1}.
sqlstore.transactionimpl.status={0} Tran[ {1} ].setStatus: {2} => {3} para {4}.


###############################################################################
# All the source files under subdir ejb.
# Message ID Range: JDO76600 - JDO76699
###############################################################################
#
#EJBHelper messages
#
# {0} - method name
ejb.ejbhelper.nonmanaged=JDO76600: no se deber\u00EDa llamar al m\u00E9todo {0} en un entorno no gestionado.

#
# Common messages between SunContainerHelper and DeploymentHelper
# so they have a neutral key, that still starts with "ejb".
#
# {0} - jndi name.
ejb.jndi.lookupfailed=JDO76604: fallo al realizar la b\u00FAsqueda en JNDI de cmp-resource ''{0}''.
JDO76604.diag.cause.1=El recurso de CMP con este nombre de JNDI no se ha registrado con esta instancia.
JDO76604.diag.cause.2=El recurso de CMP con este nombre JNDI no est\u00E1 bien escrito.
JDO76604.diag.check.1=Compruebe el nombre JNDI del recurso que tiene previsto utilizar.
JDO76604.diag.check.2=Compruebe el nombre JNDI del recurso de CMP especificado en el m\u00F3dulo.

# {0} - jndi name.
# {1} - returned class name.
ejb.jndi.unexpectedinstance=JDO76605: La b\u00FAsqueda en JNDI de cmp-resource ''{0}'' ha devuelto una instancia con un tipo inesperado: {1}.
JDO76605.diag.cause.1=El recurso de CMP con este nombre JNDI no hace referencia a jdbc-resource ni a persistence-manager-factory-resource.
JDO76605.diag.cause.2=El recurso de CMP con este nombre JNDI no est\u00E1 bien escrito.
JDO76605.diag.check.1=Compruebe el nombre JNDI del recurso que tiene previsto utilizar.
JDO76605.diag.check.2=Compruebe el nombre JNDI del recurso de CMP especificado en el m\u00F3dulo.

#
# DeploymentHelper messages - ejb
#
#
#<NOI18N: DeploymentHelper>
#
ejb.DeploymentHelper.getconnection=Obteniendo conexi\u00F3n para nombre de JNDI ''{0}''.

# The messages JDO76606 through JDO76615 that were originally here 
# have been moved to 
# cmp/support/ejb/src/com/sun/jdo/spi/persistence/support/ejb/ejbc/Bundle.properties
# As part of INF#
# So do not use these messages. 


#
#CMPHelper messages
#
ejb.cmphelper.nonmanaged=JDO76613: acceso no v\u00E1lido de CMPHelper. Esta clase se utiliza s\u00F3lo para el soporte de CMP y no se deber\u00EDa llamar fuera de un servidor de aplicaciones.

#
#SunTransactionHelper messages
#

# {0} class name
ejb.SunTransactionHelper.wrongdatasourcetype=JDO76616: DataSource no tiene el tipo esperado. Se esperaba: com.sun.appserv.jdbc.DataSource; se ha obtenido: {0}.


###############################################################################
# <Generic messages. Add new messages to this section only if none of the above categories can be used.>
###############################################################################
#
# <NOI18N: generic>
#
vendor=Sun Microsystems
# majorVersion (minorVersion) buildDate
fullVersion={0} ({1}) {2}
#
# <NOI18N: This messages are used for JDOFatalInternalException from multiple places. No need to I18N>
#
core.generic.unknownfield=El campo {0} no es miembro de la clase {1}.
core.generic.unknownexception=Se ha obtenido una excepci\u00F3n desconocida.
core.generic.nullparam=El par\u00E1metro {0} es nulo.
core.generic.notinstanceof=El objeto de la clase {0} no es una instancia de {1}.


###############################################################################
# <These messages are used from multiple places in code.It is absolutely necessary to cleanup code
# to use different messages >
###############################################################################
core.configuration.cantloadclass=Fallo al cargar la clase {0}.
sqlstore.exception.log=Exception.
jdo.lifecycle.deleted.accessField=No se puede acceder a un campo de una instancia suprimida.
