#
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
#
# Copyright (c) 1997-2017 Oracle and/or its affiliates. All rights reserved.
#
# The contents of this file are subject to the terms of either the GNU
# General Public License Version 2 only ("GPL") or the Common Development
# and Distribution License("CDDL") (collectively, the "License").  You
# may not use this file except in compliance with the License.  You can
# obtain a copy of the License at
# https://oss.oracle.com/licenses/CDDL+GPL-1.1
# or LICENSE.txt.  See the License for the specific
# language governing permissions and limitations under the License.
#
# When distributing the software, include this License Header Notice in each
# file and include the License file at LICENSE.txt.
#
# GPL Classpath Exception:
# Oracle designates this particular file as subject to the "Classpath"
# exception as provided by Oracle in the GPL Version 2 section of the License
# file that accompanied this code.
#
# Modifications:
# If applicable, add the following below the License Header, with the fields
# enclosed by brackets [] replaced by your own identifying information:
# "Portions Copyright [year] [name of copyright owner]"
#
# Contributor(s):
# If you wish your version of this file to be governed by only the CDDL or
# only the GPL Version 2, indicate your decision by adding "[Contributor]
# elects to include this software in this distribution under the [CDDL or GPL
# Version 2] license."  If you don't indicate a single choice of license, a
# recipient has the option to distribute your version of this file under
# either the CDDL, the GPL Version 2 or to extend the choice of license to
# its licensees as provided above.  However, if you add GPL Version 2 code
# and therefore, elected the GPL Version 2 license, then the option applies
# only if the new code is made subject to such option by the copyright
# holder.
#

# Resource bundle for sqlstore runtime messages
# key consists of: <subpackage>.<class>.<method>.<description>
# <subpackage> - is optional, package under runtime
# <class> - class name
# <method> - method name
# <description> - short description (use _ to represent space)
# all keys should be in lowercase
#
# Please note that many package names and classnames have changed over time.
# Unfortunately, this file was not maintained to follow above convention.
# Please ignore if the package/class name does not match actual names as today.
#
#
# The message ID for a message in persistence is derived as follows:
# JDO<2_digit_bundle_prefix><1_digit_section_number><2_digit_serial_number>
#
# The 2 digit prefix for this bundle is 76.
#
# This file is divided into the following sections:
# Under each section, messages that need not be I18Ned are separated under NOI18N. All other messages
# need to be numbered.
# 1. JDO:  PersistenceManagerFactory/PersistenceManager/ExtentCollection/LifeCycle
# 2. Model
# 3. StateManager
# 4. sql generator components: RetrieveDesc, ResultDesc plus all the files under generator subdir
# 5. SQLStoreManager
# 6. Connection/Connectionpool/Transaction/DBVendorType
# 7. EJB integration.
# 8. Generic messages.
#
# When adding a new message:
# 1. Please make sure that you add the message to the end of appropriate section.
# 2. Please add message ID to any user visible message.
# 3. The message ID for the new message = message ID for the last numbered
#    message in a section + 1.
# 4. Please do not change the message ID for existing messages. These
#    numbers are potentially mapped to more explanation about the message for
#    the end user.
#

####################################################################################################
# <All the source files under subdir impl (PersistenceManagerFactory/PersistenceManager etc.) >
# Message ID Range: JDO76000 - JDO76099
####################################################################################################
jdo.persistencemanagerfactoryimpl.getpersistencemanager.error=JDO76000: impossibile utilizzare pi\u00F9 combinazioni di nome utente/password nella stessa transazione.
jdo.persistencemanagerfactoryimpl.getpersistencemanager.notconfigured=JDO76001: PersistenceManagerFactory non configurato.
jdo.persistencemanagerfactoryimpl.notsupported=JDO76002: l'operazione non \u00E8 supportata per il PersistenceManagerFactoryImpl interno.
jdo.persistencemanagerimpl.acquireexclusivelock.interrupted=JDO76003: acquisizione del lock esclusivo non riuscita a causa di InterruptedException
jdo.persistencemanagerimpl.acquiresharelock.failed=JDO76004: acquisizione del lock condiviso non riuscita poich\u00E9 _readWriteCount \u00E8 minore di zero
jdo.persistencemanagerimpl.acquiresharelock.interrupted=JDO76005: acquisizione del lock condiviso non riuscita a causa di InterruptedException
jdo.persistencemanagerimpl.another_pm=JDO76006: l'oggetto \u00E8 associato a un altro Persistence Manager.
jdo.persistencemanagerimpl.assertactivetransaction.error=JDO76007: la transazione associata a questo Persistence Manager non \u00E8 attiva.
jdo.persistencemanagerimpl.assertclosed.closed=JDO76008: Persistence Manager \u00E8 chiuso.
jdo.persistencemanagerimpl.assertpersistencecapable.error=JDO76009: la classe {0} non \u00E8 stata migliorata per la trasparenza persistente. Usare il packager JAR o WAR dell''IDE per raggruppare le classi con funzionalit\u00E0 di persistenza prima dell''esecuzione. In alternativa, impostare la propriet\u00E0 Executor della classe principale su Persistence Executor per l''esecuzione dall''IDE.
jdo.persistencemanagerimpl.close.activetransaction=JDO76010: esiste una transazione aperta associata a questo Persistence Manager.
jdo.persistencemanagerimpl.fetchinstance.none=JDO76012: oggetto non trovato per questo ObjectId.
jdo.persistencemanagerimpl.internaldeletepersistent.transient=JDO76014: impossibile eliminare oggetto non persistente.
jdo.persistencemanagerimpl.internalmakepersistent.dups=JDO76015: un'istanza con la stessa chiave primaria esiste gi\u00E0 nella cache di PersistenceManager.
jdo.persistencemanagerimpl.loadclassforoid.wrongoidclass=JDO76016: errore durante il recupero della classe di oggetto da OID.
jdo.persistencemanagerimpl.newscoinstance.wrongclass=JDO76017: impossibile creare un''istanza SCO della classe {0} poich\u00E9 il tipo non \u00E8 valido.
jdo.persistencemanagerimpl.notprocessed=JDO76018: impossibile cancellare istanze persistenti a causa di dipendenze circolari.
jdo.persistencemanagerimpl.releaseexclusivelock.failed=JDO76019: impossibile rilasciare il lock esclusivo perch\u00E9 _readWriteCount \u00E8 maggiore di zero
jdo.persistencemanagerimpl.releasesharelock.failed=JDO76020: impossibile rilasciare il lock condiviso perch\u00E9 _readWriteCount \u00E8 pari a zero
jdo.persistencemanagerwrapper.invalidpm=JDO76021: PersistenceManagerWrapper \u00E8 chiuso.
jdo.extentcollection.constructor.invalidclass=JDO76022: classe ''{0}'' non valida per la raccolta di extent.
jdo.extentcollection.constructor.nonpc=JDO76023: la classe ''{0}'' non ha funzionalit\u00E0 di persistenza.
jdo.extentcollection.constructor.subclasses=JDO76024: classi secondarie di opzioni true non \u00E8 supportato per le raccolte di extent.
jdo.extentcollection.illegalmodification=JDO76025: modifica non valida della raccolta di extent per la classe ''{0}''.
jdo.extentcollection.methodnotsupported=JDO76026: metodo {0} di raccolta degli extent non supportato.
jdo.lifecycle.xactnotactive=JDO76027: per eseguire questa operazione \u00E8 necessaria una transazione attiva.
jdo.persistencemanagerimpl.newinstance.badsm=JDO76028: configurazione di StateManager non completa.
jdo.persistencemanagerimpl.setjtatransaction.notnulljta=JDO76029: tentativo di sostituire javax.transaction.Transaction: {0} non nulla con {1}.
jdo.persistencemanagerfactoryimpl.getpersistencemgr.closed=JDO76030: PersistenceManager per questa javax.transaction.Transaction: {0} \u00E8 gi\u00E0 chiuso o in fase di commit.
jdo.persistencemanagerfactoryimpl.registerpm.registered=JDO76031: questa istanza di javax.transaction.Transaction: {0} \u00E8 gi\u00E0 registrata con un altro PersistenceManager: {1}.
jdo.persistencemanagerimpl.verificationfailed=JDO76032: verifica dell'istanza di coerenza delle versioni a fronte del data store non riuscita.
jdo.persistencemanagerfactoryimpl.getversionconsistencycache.nullstore=JDO76033: StoreManager non configurato.

#
# <NOI18N: LifeCycle>
#
sqlstore.state.lifecyclestate.changestate=LifeCycleState.changeState(), stato precedente = {0}, nuovo stato = {1}.
sqlstore.state.lifecyclestate.initial=LifeCycleState.getLifeCycleState(), stato iniziale = {0}.

#
# <NOI18N: PersistenceManager>
#
sqlstore.persistencemgr.acquireexclusivelock.count=acquireExclusiveLock(), thread {0} con _readWriteCount = {1}.
sqlstore.persistencemgr.acquireexclusivelock=acquireExclusiveock(), thread {0} in prospettiva di attesa.
sqlstore.persistencemgr.acquiresharedlock.rdwrcount=acquireShareLock(), il thread {0} ha acquisito il lock condiviso con _readWriteCount ={1}.
sqlstore.persistencemgr.acquiresharedlock=acquireShareLock(), thread {0} in prospettiva di attesa.
sqlstore.persistencemgr.aftercompletion.process=---PersistenceManagerImpl.afterCompletion() process: {0}.
sqlstore.persistencemgr.aftercompletion=---PersistenceManagerImpl.afterCompletion() abort: {0}.
sqlstore.persistencemgr.assertactivetx.closed=--- PersistenceManagerImpl.assertActiveTransaction: Closed for  {0}.
sqlstore.persistencemgr.assertactivetx=--- PersistenceManagerImpl.assertActiveTransaction: {0}.
sqlstore.persistencemgr.assertisopen=--- PersistenceManagerImpl.assertIsOpen: chiuso per {0}.
sqlstore.persistencemgr.beforecompletion=---PersistenceManagerImpl.beforeCompletion().
sqlstore.persistencemgr.cacheproperties=Propriet\u00E0 cache PersistenceManagerImpl: _txCacheInitialCapacity={0}, _flushedCacheInitialCapacity={1}, _flushedCacheLoadFactor={2}, _weakCacheInitialCapacity={3}, _weakCacheLoadFactor={4}.
sqlstore.persistencemgr.deregisterinstance.verified=---PersistenceManagerImpl.deregisterInstance() -- deregistered with verify.
sqlstore.persistencemgr.deregisterinstance.verify=---PersistenceManagerImpl.deregisterInstance() with verify SM -- oid: {0}  for PersistenceManager: {1}  and JTA: {2}.
sqlstore.persistencemgr.deregisterinstance=---PersistenceManagerImpl.deregisterInstance() oid: {0}  for PersistenceManager: {1}  and JTA: {2}.
sqlstore.persistencemgr.getbyobjid=---PersistenceManagerImpl.getObjectById() OID:{0} for PersistenceManager: {1} and JTA: {2}.
sqlstore.persistencemgr.getcurrentwrapper=---PersistenceManagerImpl.getCurrentWrapper() > current: {0}.
sqlstore.persistencemgr.getobjid.notpc=---PersistenceManagerImpl.getObjectId() NOT PC: {0}  for PersistenceManager: {1}.
sqlstore.persistencemgr.getobjid.notpm=---PersistenceManagerImpl.getObjectId() NOT PM: {0} for PersistenceManager: {1}  and JTA: {2}.
sqlstore.persistencemgr.getobjid= :{0} ---PersistenceManagerImpl.getObjectId() PC: {1} for PersistenceManager: {2} and JTA: {3}.
sqlstore.persistencemgr.internalcloneoid.old=---PersistenceManagerImpl.internalCloneOid(): old: {0} new: {1} same: {2}.
sqlstore.persistencemgr.internalcloneoid=---PersistenceManagerImpl.internalCloneOid() errore: {0}.
sqlstore.persistencemgr.isactivetx=---PersistenceManagerImpl.isActiveTransaction(): {0}.
sqlstore.persistencemgr.isnontxread=---PersistenceManagerImpl.isNontransactionalRead(): {0}.
sqlstore.persistencemgr.isoptimistic=---PersistenceManagerImpl.isOptimisticTransaction(): {0}.
sqlstore.persistencemgr.loadingclass=Caricamento in corso... Nome classe: {0}.
sqlstore.persistencemgr.loadingfile=Caricamento in corso... Nome file: {0} {1} {2}.
sqlstore.persistencemgr.makepersistent.done=---PersistenceManagerImpl.makePersistent() {0}  finished for: {1} and JTA: {2}.
sqlstore.persistencemgr.makepersistent= {0} ---PersistenceManagerImpl.makePersistent() PC: {1} for PersistenceManager: {2} and JTA: {3}.
sqlstore.persistencemgr.newcollection=---PersistenceManagerImpl.newCollectionInstanceInternal() type: {0}.
sqlstore.persistencemgr.popcurrentwrapper=---PersistenceManagerImpl.popCurrentWrapper() > current: {0}  prev: {1}.
sqlstore.persistencemgr.pushcurrentwrapper=---PersistenceManagerImpl.pushCurrentWrapper() > current: {0}  new: {1}.
sqlstore.persistencemgr.registerinstance= {0} ---PersistenceManagerImpl.registerInstance() oid/sm: {1}/{2}  for PersistenceManager: {3}  and JTA: {4}.
sqlstore.persistencemgr.registerinstancein_txc=registerInstance in TXC :{0} / {1} for PersistenceManager: {2} and JTA: {3}.
sqlstore.persistencemgr.registerinstancein_wkc=registerInstance in WKC.
sqlstore.persistencemgr.releaseexclusivelock=releaseExclusiveock(), thread {0} con _readWriteCount = {1}.
sqlstore.persistencemgr.releasesharedlock=releaseShareLock(), thread {0} con _readWriteCount = {1}.
sqlstore.persistencemgr.replacingdeletedinstance=Sostituzione dell''istanza eliminata con una nuova per l''ID oggetto: {0}.
sqlstore.persistencemgr.setkeyfields=---PersistenceManagerImpl.setKeyFields() errore: {0}.
#
# <NOI18N: PersistenceManagerFactory>
#
sqlstore.sqlpersistencemgrfactory.getfrompool.pmt=<--SQLPersistenceManagerFactory.getFromPool() PM: {0} for JTA {1}.
sqlstore.sqlpersistencemgrfactory.getfrompool=<--SQLPersistenceManagerFactory.getFromPool().
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.found= {0} <->SQLPersistenceManagerFactory.getPersistenceManager() ha trovato javax.transaction. Transazione: {1}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.jdotx.notfound=<->SQLPersistenceManagerFactory.getPersistenceManager() non ha trovato la transazione JDO.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.jdotx=<->SQLPersistenceManagerFactory.getPersistenceManager() JDO Transaction: {0}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.pmclosedfor= {0} <->SQLPersistenceManagerFactory.getPersistenceManager() PM \u00E8 chiuso per: {1}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.pmt= {0} <->SQLPersistenceManagerFactory.getPersistenceManager() : {1} for JTA: {2}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr=:{0} -->SQLPersistenceManagerFactory.getPersistenceManager().
sqlstore.sqlpersistencemgrfactory.init=---SQLPersistenceManagerFactory.initialize().
sqlstore.sqlpersistencemgrfactory.pmCacheBucketSize=---SQLPersistenceManagerFactory pmCacheBucketSize = {0}.
sqlstore.sqlpersistencemgrfactory.pmCacheInitialCapacity=---SQLPersistenceManagerFactory pmCacheInitialCapacity = {0}.
sqlstore.sqlpersistencemgrfactory.registerpersistencemgr.pmt=<->SQLPersistenceManagerFactory.registerPersistenceManager() PM: {0} for JTA Tx: {1}.
sqlstore.sqlpersistencemgrfactory.releasepm.pmt=---SQLPersistenceManagerFactory.releasePersistenceManager() PM:{0} for JTA Tx: {1}.
sqlstore.sqlpersistencemgrfactory.returnToPool=<--SQLPersistenceManagerFactory.returnToPool().


###############################################################################
# <Model>
# Message ID Range: JDO76100 - JDO76199
###############################################################################
core.configuration.columnnotable=JDO76100: il descrittore della colonna non dispone di un descrittore tabella valido.
core.configuration.fieldnotable=JDO76101: il campo {0} non \u00E8 associato ad alcuna tabella.
core.configuration.fieldnotmapped=JDO76102: il campo persistente {0} per la classe {1} non \u00E8 mappato.
core.configuration.iddescnofield=JDO76103: l'oggetto SqlIDDesc non \u00E8 stato impostato correttamente. Nessun descrittore di campo disponibile.
core.configuration.loadfailed.class=JDO76104: caricamento della configurazione per la classe {0} non riuscito.
core.configuration.noneexistentpkfield=JDO76105: il campo {0} nella classe ObjectId {1} non esiste nella classe PersistenceCapable {2}.
core.configuration.unsupportedconsistencylevel=JDO76106: la classe {0} ha un livello di coerenza non supportato. I livelli di coerenza supportati al momento sono "none", "check-modified-at-commit", "lock-when-loaded" e "check-version-of-accessed-instances".
core.configuration.validationfailed=JDO76107: il mapping per la classe {0} non \u00E8 valido:\n{1}.
core.configuration.validationproblem=JDO76108: errore di convalida nella classe {0}: {1}
#
# <FieldDesc validation at runtime>
#
core.fielddesc.minvalue=JDO76109: il valore: {0} \u00E8 minore del minimo consentito: {1} per il tipo di campo {2}.
core.fielddesc.maxvalue=JDO76110: il valore: {0} \u00E8 maggiore del massimo consentito: {1} per il tipo di campo {2}.
core.configuration.noneexistentvcfield=JDO76111: il campo {0} \u00E8 contrassegnato come campo versione ma non esiste nella classe PersistenceCapable {1}.
core.configuration.loadfailed.field=JDO76112: caricamento della configurazione per il campo {0} nella classe {1} non riuscito.

#
# <NOI18N: model>
#
sqlstore.model.classdesc.assocrelatedfield=campo relazione associato = {0}.
sqlstore.model.classdesc.createsqldesc=creazione SqlIDDesc da {0}.
sqlstore.model.classdesc.fieldinfo=nome campo = {0}, ID = {1}.
sqlstore.model.classdesc.general={0}.{1} =>{2}
sqlstore.model.classdesc.getlocalfielddesc=<-> SqlPersistenceDesc.getLocalFieldDesc(), classe ={0}, aggiunto campo nascosto {1} per la colonna {2}.
sqlstore.model.classdesc.loadedclass=Caricamento della classe OID = {0} riuscito.
sqlstore.model.classdesc.persistconfiginit.exit=<-- SqlPersistenceConfig.initialize().
sqlstore.model.classdesc.persistconfiginit=--> SqlPersistenceConfig.initialize(), classe = {0}.
sqlstore.model.classdesc.pkfield=Campo PK = {0}.
sqlstore.model.classdesc.primarytrackedfield=il campo {0} \u00E8 il campo registrato primario.
sqlstore.model.classdesc.unsetconcurrencychk=annullamento dell''impostazione della propriet\u00E0 IN_CONCURRENCY_CHECK per lf {0}.
sqlstore.model.classdesc.unsetrefintegrityupdate=annullamento dell''impostazione della propriet\u00E0 REF_INTEGRITY_UPDATES per ff {0}.
sqlstore.model.classdesc.vcfield=Campo coerenza versione = {0}.
sqlstore.model.fielddesc.addingfield=aggiunta del campo {0} da registrare mediante il campo {1}.
sqlstore.model.fielddesc.convertvalue.from_to=convertValue: {0} da: {1} in: {2}.
sqlstore.model.fielddesc.convertvalue.hidden=convertValue: {0} nascosto... torna.
sqlstore.model.fielddesc.convertvalue=convertValue: NULL... restituisce.
sqlstore.model.fielddesc.fieldname={0} = {1}.
sqlstore.model.fielddesc.setupdesc=setupDesc(): fieldName {0} fieldType {1}.
sqlstore.model.configcacheimpl.size_before=dimensione {0} prima del cleanup: {1}.
sqlstore.model.configcacheimpl.size_after=dimensione {0} dopo il cleanup: {1}.


###############################################################################
# <StateManager>
# Message ID Range: JDO76200 - JDO76299
###############################################################################
core.statemanager.anotherowner=JDO76200: impossibile assegnare istanza SCO di propriet\u00E0 di un altro oggetto.
core.statemanager.cantnewoid=JDO76201: creazione di una nuova istanza di chiave primaria della classe {0} non riuscita.
core.statemanager.cantschedulejointable=JDO76202: pianificazione della voce della tabella dei collegamenti tra la classe {0} e {1} non riuscita. La descrizione del campo relazione \u00E8 nulla.
core.statemanager.cantsetkeyfield=JDO76203: impostazione del valore per il campo chiave primaria {0} non riuscita.
core.statemanager.conflictingvalues=JDO76204: conflitto di valori tra il campo {0} e il campo {1} mappati nella stessa colonna
core.statemanager.getfieldfailed=JDO76205: tentativo di ottenere il campo non riuscito.
core.statemanager.invalidpk=JDO76206: campo chiave primaria nullo non valido {0} durante il ricaricamento di un''istanza di una classe con funzionalit\u00E0 di persistenza {1}. L''ObjectId dell''istanza \u00E8 {2}.
core.statemanager.nopkupdate=JDO76207: aggiornamento di un campo chiave primaria non consentito.
core.statemanager.nopm=JDO76208: lo State Manager non contiene riferimenti al Persistence Manager.
core.statemanager.notnavigable=JDO76209: si \u00E8 verificato un tentativo di accesso al campo {0} della classe {1}. In precedenza non \u00E8 stata creata un''istanza di questo campo e questa classe non consente la navigazione dinamica. \u00C8 necessario richiedere il campo al momento del recupero della classe oppure consentire la navigazione dinamica in modo da consentire il recupero automatico all''accesso.
core.statemanager.objectnotfound=JDO76210: l'oggetto non esiste nel data store.
core.statemanager.poshiddenindex=JDO76211: l''indice di un campo nascosto deve essere negativo, ma \u00E8 stato ottenuto l''indice {0}.
core.statemanager.readonly=JDO76212: \u00E8 stato eseguito un tentativo di modificare il campo di sola lettura {0} della classe {1}.
core.statemanager.releaselock.wrongthread=JDO76213: questo thread {0} non contiene il lock StateManager.
core.statemanager.setfieldfailed=JDO76214: impostazione del campo non riuscita.
core.statemanager.wrongusageforoverlappingpkfkdelete=JDO76215: tentativo errato di rimuovere un'istanza da una relazione gestita. La relazione \u00E8 definita da una colonna chiave primaria sull'altro lato. Le operazioni di rimozione su una raccolta richiedono l'aggiornamento della colonna sull'altro lato, ma l'aggiornamento della chiave primaria non \u00E8 consentito. Per questo motivo, la rimozione di un'istanza da una raccolta di relazioni gestite definita da una chiave primaria pu\u00F2 essere eseguita solo eliminando l'istanza, in modo esplicito o mediante l'eliminazione a catena.
core.statemanager.toomanyrows=JDO76215: restituite pi\u00F9 righe per una delle tabelle mappate alla classe {0}. Ogni tabella mappata a una classe deve avere solo una riga per ogni istanza dell''oggetto.
core.statemanager.copyFields.mismatch=JDO76216: tentativo di copia di campi tra StateManager che gestiscono istanze di tipi diversi: {0} e {1}.

#
# <NOI18N: StateManager>
#
sqlstore.sqlstatemanager.adddependency=<-> SQLStateManager.addDependency(), questo StateManager: {0}, altro StateManager: {1}.
sqlstore.sqlstatemanager.addupdate=<-> SQLStateManager.addUpdatedForeignReference(), lobj={0}, f={1}, fobj={2}, refCount={3}.
sqlstore.sqlstatemanager.applyupdates.exit=<-- SqlStateManager.applyUpdates().
sqlstore.sqlstatemanager.applyupdates=--> SqlStateManager.applyUpdates(), campo = {0}.
sqlstore.sqlstatemanager.clearpersistencefields.exit=<--- SqlStateManager.clearPersistenceFields().
sqlstore.sqlstatemanager.clearpersistencefields=--> SqlStateManager.clearPersistenceFields().
sqlstore.sqlstatemanager.copychanges.exit=<-- SQLStateManager.copyChanges().
sqlstore.sqlstatemanager.copychanges=--> SQLStateManager.copyChanges(), State Manager = {0}.
sqlstore.sqlstatemanager.deletepersistence=<-> SqlStateManager.deletePersistence(), tipo = {0}.
sqlstore.sqlstatemanager.getbeforeimage.exit=<-- SqlStateManager.getBeforeImage().
sqlstore.sqlstatemanager.getbeforeimage=--> SqlStateManager.getBeforeImage(), tipo = {0}.
sqlstore.sqlstatemanager.isbeforeimagerequired=isBeforeImageRequired \u00E8: {0}.
sqlstore.sqlstatemanager.loadforread.exit=<-- SQLStateManager.loadForRead().
sqlstore.sqlstatemanager.loadforread=--> SQLStateManager.loadForRead().
sqlstore.sqlstatemanager.loadforupdate.exit=<-- SQLStateManager.loadForUpdate().
sqlstore.sqlstatemanager.loadforupdate=--> SQLStateManager.loadForUpdate().
sqlstore.sqlstatemanager.loggingfield=registrazione campo = {0} con il valore = {1}.
sqlstore.sqlstatemanager.makedirty.fixscocollection=--- SqlStateManager.makeDirty(), correzione di SCOCollection.
sqlstore.sqlstatemanager.makedirty.fixscodate=--- SqlStateManager.makeDirty(), correzione di SCODate.
sqlstore.sqlstatemanager.makedirty=--> SqlStateManager.makeDirty(), campo = {0}.
sqlstore.sqlstatemanager.makedirtyfield=Campo contrassegnato come non corretto = {0}.
sqlstore.sqlstatemanager.makepersistence=<-> SqlStateManager.makePersistence(), tipo = {0}.
sqlstore.sqlstatemanager.makepresent=--> SqlStateManager.makePresent(), campo = {0}.
sqlstore.sqlstatemanager.marking=Contrassegno di: {0} come presente.
sqlstore.sqlstatemanager.newtype=Nuovo tipo: {0}.
sqlstore.sqlstatemanager.nosuchmethodexcep.clone=Eccezione: copia di {0}... per il tipo {1}.
sqlstore.sqlstatemanager.preparegetfield.exit=<-- SqlStateManager.prepareGetField().
sqlstore.sqlstatemanager.preparegetfield=--> SqlStateManager.prepareGetField(), nome = {0}.
sqlstore.sqlstatemanager.preparesetfield.exit=<-- SQLStateManager.prepareSetField().
sqlstore.sqlstatemanager.preparesetfield=--> SQLStateManager.prepareSetField(), nome = {0}.
sqlstore.sqlstatemanager.preparetoupdateph1.exit=<-- SqlStateManager.prepareToUpdateI().
sqlstore.sqlstatemanager.preparetoupdateph1=--> SqlStateManager.prepareToUpdatePhaseI(), tipo = {0}.
sqlstore.sqlstatemanager.preparetoupdateph2.exit=<-- SqlStateManager.prepareToUpdateII().
sqlstore.sqlstatemanager.preparetoupdateph2=--> SqlStateManager.prepareToUpdatePhaseII(), tipo = {0}.
sqlstore.sqlstatemanager.preparetoupdateph3.exit=<-- SqlStateManager.prepareToUpdateIII().
sqlstore.sqlstatemanager.preparetoupdateph3=--> SqlStateManager.prepareToUpdatePhaseIII(), tipo = {0}.
sqlstore.sqlstatemanager.prepareupdatefield.exit=<-- SQLStateManager.prepareUpdateField().
sqlstore.sqlstatemanager.prepareupdatefield=--> SQLStateManager.prepareUpdateField(), nome = {0} per lo stato: {1}.
sqlstore.sqlstatemanager.prepareupdatefieldspl.exit=<-- SQLStateManager.prepareUpdateFieldSpecial().
sqlstore.sqlstatemanager.prepareupdatefieldspl=--> SQLStateManager.prepareUpdateFieldSpecial, nome = {0} per lo stato: {1}.
sqlstore.sqlstatemanager.processcollectionupdate.exit=<-- SQLStateManager.processCollectionUpdates().
sqlstore.sqlstatemanager.processcollectionupdate=--> SQLStateManager.processCollectionUpdates(), beforeList={0}, afterlist={1}.
sqlstore.sqlstatemanager.processforeign=campo esterno processo ={0}.
sqlstore.sqlstatemanager.processforeignfield.remove=-- SQLStateManager.processForeignField(): era Collection - rimosso.
sqlstore.sqlstatemanager.processforeignfield.remove_from_bi=-- SQLStateManager.processForeignField(): \u00E8 SCOCollection - rimosso da BI.
sqlstore.sqlstatemanager.processforeignfield.reset=-- SQLStateManager.processForeignField(): era SCOCollection - reimpostato.
sqlstore.sqlstatemanager.processforeignfield=-- SQLStateManager.processForeignField(): valore: {0} tipo: {1}.
sqlstore.sqlstatemanager.realizefield.exit=<-- SqlStateManager.realizeField().
sqlstore.sqlstatemanager.realizefield=--> SqlStateManager.realizeField(), nome = {0}.
sqlstore.sqlstatemanager.realizeforeignfield.exit=<-- SqlStateManager.realizeField(), campo realizzato = {0}.
sqlstore.sqlstatemanager.realizeforeignfield=--> SqlStateManager.realizeField(), nome = {0}.
sqlstore.sqlstatemanager.recordingfield=registrazione del campo = {0}.
sqlstore.sqlstatemanager.refreshpersistent.exit=<-- SqlStateManager.refreshPersistent().
sqlstore.sqlstatemanager.refreshpersistent=--> SqlStateManager.refreshPersistence(), tipo = {0}.
sqlstore.sqlstatemanager.reload.exit=<-- SqlStateManager.reload(FieldDesc).
sqlstore.sqlstatemanager.reload=--> SqlStateManager.reload(FieldDesc), tipo = {0}, campo = {1}.
sqlstore.sqlstatemanager.removeupdate=<-> SQLStateManager.removeUpdatedForeignReference(), lobj={0}, f={1}, fobj={2}, refCount={3}.
sqlstore.sqlstatemanager.replaceobjectfield.unsetsco=-- SqlStateManager.replaceObjectField(), annullamento impostazione SCO.
sqlstore.sqlstatemanager.replaceobjectfield=-- SqlStateManager.replaceObjectField(), campo = {0}, tipo = {1}.
sqlstore.sqlstatemanager.reset=--> SqlStateManager.reset(), retValues = {0}, wasNew: {1}, keepState: {2}.
sqlstore.sqlstatemanager.resettingcollection=Reimpostazione raccolta.
sqlstore.sqlstatemanager.resettingdate=Reimpostazione data.
sqlstore.sqlstatemanager.resolvedependencies=<-> SQLStateManager.resolveDependencies(), oggetto = {0}.
sqlstore.sqlstatemanager.resolvedependency=<-> SQLStateManager.resolveDependency(), dipendenza risolta: lobj={0}, f={1}, fobj={2}.
sqlstore.sqlstatemanager.retrieve.exit=<-- SqlStateManager.retrieve().
sqlstore.sqlstatemanager.retrieve=--> SqlStateManager.retrieve(), nome = {0}.
sqlstore.sqlstatemanager.retrieveforeign.exit=<-- SqlStateManager.retrieveForeign().
sqlstore.sqlstatemanager.retrieveforeign=--> SqlStateManager.retrieveForeign(), nome = {0}.
sqlstore.sqlstatemanager.unsetmask=annullamento dell''impostazione delle maschere per il campo = {0}.
sqlstore.sqlstatemanager.unconditionalreload.exit=<-- SqlStateManager.reload().
sqlstore.sqlstatemanager.unconditionalreload=--> SqlStateManager.reload(), tipo = {0}.
sqlstore.sqlstatemanager.updatebeforeimage=<-> SQLStateManager.updateBeforeImage(), nome = {0}, valore = {1}.
sqlstore.sqlstatemanager.updateobjfield.exit=<-- SQLStateManager.updateObjectField().
sqlstore.sqlstatemanager.updateobjfield=--> SQLStateManager.updateObjectField(), nome = {0}, tipo = {1}.
sqlstore.sqlstatemanager.updatepersistent.exit=<-- SqlStateManager.updatePersistent().
sqlstore.sqlstatemanager.updatepersistent.immediateflush=<--> SqlStateManager.updatePersistent(), richiesto flush immediato: oggetto ={0}, successivo ={1}.
sqlstore.sqlstatemanager.updatepersistent.skipped=<--> SqlStateManager.updatePersistent() saltato, tipo ={0}, oggetto = {1}.
sqlstore.sqlstatemanager.updatepersistent=--> SqlStateManager.updatePersistent(), tipo = {0}.
sqlstore.sqlstatemanager.updatetrackedfields.exit=<-- updateTrackedFields().
sqlstore.sqlstatemanager.updatetrackedfields=--> updateTrackedFields(), f = {0} valore = {1}  fieldToIgnore = {2}.


###############################################################################
# <sql generator components: All the source files under sql.>
# Message ID Range: JDO76300 - JDO76399
###############################################################################
core.constraint.duporderby=JDO76300: il vincolo \u00E8 di tipo \\"order by\\" per il campo {0} che \u00E8 gi\u00E0 specificato in un vincolo \\"order by\\".
core.constraint.fielddisallowed=JDO76301: \u00E8 stato specificato il parametro fieldName, non consentito con l''operazione {0}.
core.constraint.fieldrequired=JDO76302: parametro fieldName mancante, ma l''operazione {0} richiede un campo.
core.constraint.illegalParameterInfo=JDO76303: addConstraint() per OP_PARAMETER deve essere richiamato con valore di tipo ParameterInfo.
core.constraint.illegalnode=JDO76304: nodo di vincolo non valido {0} nello stack SqlConstraint.
core.constraint.illegalop=JDO76305: il parametro dell''operazione conteneva un valore {0} non valido.
core.constraint.needfieldnamenode=JDO76306: errore nello stack del vincolo. \u00C8 previsto un nome di campo.
core.constraint.needfieldnode=JDO76307: errore nello stack del vincolo. \u00C8 prevista una descrizione di campo.
core.constraint.needvalnode=JDO76308: errore nello stack del vincolo. \u00C8 previsto un valore.
core.constraint.stackempty=JDO76309: lo stack del vincolo \u00E8 vuoto -- valori non sufficienti per il numero dell'operatore.
core.constraint.unknownfield=JDO76310: il campo {0} specificato nel descrittore di recupero non \u00E8 un membro della classe {1}.
core.constraint.valdisallowed=JDO76311: \u00E8 stato specificato il parametro value, non consentito con l''operazione {0}.
core.constraint.valrequired=JDO76312: parametro value mancante, ma l''operazione {0} richiede un valore.
sqlstore.resultdesc.errorgettingvalefromresulset=JDO76313: errore durante il tentativo di ottenere il valore da resultset all''indice {0} come resultType {1}. columnSqlType {2}. Eccezione: {3}
sqlstore.resultdesc.foreignfieldprojection=JDO76314: le query relative a {0} non devono avere proiezioni su un campo relazione.
sqlstore.resultdesc.unknownfieldtype=JDO76317: riscontrato tipo di campo sconosciuto {0}.
sqlstore.retrievedesc.toomanyprojections=JDO76318: impossibile impostare pi\u00F9 proiezioni per RetrieveDesc.
sqlstore.retrievedesc.toomanyresulttypes=JDO76319: impossibile impostare pi\u00F9 tipi di risultati per RetrieveDesc.
sqlstore.selectstatement.noupdatelocksupport=JDO76320: uno dei tipi di oggetto previsti in questa query \u00E8 al livello di coerenza "lock-when-loaded". L'applicazione di questo livello di coerenza richiede che il data store supporti il blocco per l'aggiornamento a livello di riga. Il data store non supporta il blocco per l'aggiornamento a livello di riga.
sqlstore.sql.generator.statement.likeescapenotsupported=JDO76321: la clausola LIKE ESCAPE non \u00E8 supportata in questo database.
sqlstore.sql.generator.statement.positionthreeargsnotsupported=JDO76322: il terzo argomento per la clausola POSITION deve essere 1.
core.configuration.classnotmapped=JDO76323: la classe {0} non \u00E8 mappata.
core.configuration.classnotmappedtotable=JDO76324: la classe {0} non \u00E8 mappata alla tabella {1}.
sqlstore.sql.generator.statement.unexpectedconstraint=JDO76325: un vincolo per un''operazione {0} non pu\u00F2 mai essere la radice di una clausola WHERE.

# <I18N: sql generator>
# Following messages are used within other messages. They need to be i18ned but need not be numbered.
#
sqlstore.sql.generator.statement.sqlStatement=Istruzione SQL
sqlstore.sql.generator.statement.withinputvalues= valori di input:
sqlstore.sql.generator.statement.withnoinputvalues= nessun valore di input.


#
# <ResultDesc NOI18N>
#
sqlstore.resultdesc.deserializing=deserializzazione = {0}.
sqlstore.resultdesc.marking_field=campo locale {0} contrassegnato come presente.
sqlstore.resultdesc.marking_foreign_field=campo esterno {0} contrassegnato come presente.
sqlstore.resultdesc.marking_key_field=campo chiave {0} contrassegnato come presente.
sqlstore.resultdesc.returning_field=restituzione del campo {0} come proiezione.
#
# <Misc. SQLStore NOI18N >
#
sqlstore.sql.concurrency.concurrencychkdirty.exit=--> ConcurrencyCheckDirty.update().
sqlstore.sql.concurrency.concurrencychkdirty=--> ConcurrencyCheckDirty.update(), beforeImage = {0}.
sqlstore.sql.concurrencyoptverify.resumetx=<--> ConcurrencyOptVerify.resume(), transazione ripresa = {0}.
sqlstore.sql.concurrencyoptverify.suspendtx=<--> ConcurrencyOptVerify.suspend(), transazione sospesa = {0}.
sqlstore.sql.concurrencyoptverify.update.exit=<-- ConcurrencyOptVerify.update().
sqlstore.sql.concurrencyoptverify.update=--> ConcurrencyOptVerify.update(), beforeImage = {0}.
sqlstore.sql.generator.dbstatement.addbatch=addbatch ({0})
sqlstore.sql.generator.dbstatement.bindinputcolumn=Indice bindInputColumn: {0}, valore: {1}, sqlType: {2}.
sqlstore.sql.generator.dbstatement.executebatch=executeBatch esegue {0} comando/i
sqlstore.sql.generator.selectqueryplan.processforeignfield.exit=<-- SelectQueryPlan.processForeignFields().
sqlstore.sql.generator.selectqueryplan.processforeignfield=--> SelectQueryPlan.processForeignFields(), classe = {0}.
sqlstore.sql.generator.selectqueryplan.processlocalfield.exit=<-- SelectQueryPlan.processLocalFields().
sqlstore.sql.generator.selectqueryplan.processlocalfield=--> SelectQueryPlan.processLocalFields(), classe = {0}.
sqlstore.sql.generator.selectqueryplan.processstmts.exit=<-- SelectQueryPlan.processStatements().
sqlstore.sql.generator.selectqueryplan.processstmts=--> SelectQueryPlan.processStatements(), classe = {0}, istruzioni = {1}.
sqlstore.sql.updateobjdescimpl.afterimagenull=AfterImage non impostato.
sqlstore.sql.updateobjdescimpl.beforeimagenull=BeforeImage non impostato.
sqlstore.sql.updateobjdescimpl.markrelationshipchange=<--> UpdateDesc.markRelationshipChange().
sqlstore.sql.updateobjdescimpl.updated={0} \u00E8 aggiornato.


###############################################################################
# <SQLStoreManager>
# Message ID Range: JDO76400 - JDO76499
###############################################################################
#
# <SQLStoreManager>
#
core.persistencestore.jdbcerror=JDO76400: rilevata una SQLException di JDBC durante l''esecuzione dell''istruzione SQL:\n{0}.\nEsaminare la SQLException per ulteriori informazioni.
sqlstore.retrievedesc.stmntsnotjoined=JDO76401: istruzioni SQL multiple non supportate per una RetrieveDesc.
core.persistencestore.toofewrows=JDO76402: \u00E8 stato restituito un numero di righe inferiore dal database nel tentativo di ottenere il valore dall''associazione {1} della classe {0} rispetto alla cardinalit\u00E0 consentita da questa associazione. Il numero minimo di righe consentito \u00E8 {2}.
core.persistencestore.toomanyobjforcard1=JDO76403: database non coerente con il modello persistente. Un tentativo di recuperare l''oggetto a cui fa riferimento l''associazione {1} della classe {0} ha recuperato {2} elementi, ma pu\u00F2 esserne gestito solo 1, poich\u00E9 il limite superiore di cardinalit\u00E0 per l''associazione \u00E8 1.
core.persistencestore.toomanyrows=JDO76405: \u00E8 stato restituito un numero di righe superiore dal database nel tentativo di ottenere il valore per l''associazione {1} della classe {0} rispetto alla cardinalit\u00E0 consentita da questa associazione. Il numero massimo di righe consentito \u00E8 {2}.
core.store.concurrentaccess=JDO76406: eccezione di accesso concorrente: l''oggetto relativo a {0} \u00E8 stato aggiornato o eliminato da un''altra transazione.
sqlstore.sqlstoremanager.errorcloseresultset=JDO76407: errore durante la chiusura del set di risultati SQL. Eccezione: {0}
sqlstore.sqlstoremanager.errorclosestatement=JDO76408: errore durante la chiusura dell''istruzione SQL. Eccezione: {0}
sqlstore.sql.generator.selectqueryplan.plansnotjoined=JDO76409: piani query multipli non supportati per una RetrieveDesc.

#
# <NOI18N: SQLStoreManager>
#
sqlstore.sqlstoremanager.executeQuery.exit=<-- SQLStoreManager.executeQuery().
sqlstore.sqlstoremanager.executeQuery=--> SQLStoreManager.executeQuery().
sqlstore.sqlstoremanager.executeupdate.exit=<-- SQLStoreManager.executeUpdate(), righe interessate = {0}.
sqlstore.sqlstoremanager.executeupdate=--> SQLStoreManager.executeUpdate().
sqlstore.sqlstoremanager.executeupdatebatch.addbatch={0}; aggiungere un batch.
sqlstore.sqlstoremanager.executeupdatebatch.exit=<-- SQLStoreManager.executeUpdateBatch().
sqlstore.sqlstoremanager.executeupdatebatch.exit.flush=<-- SQLStoreManager.executeUpdateBatch(), righe interessate = {0}.
sqlstore.sqlstoremanager.executeupdatebatch.flushbatch={0}; svuotare il batch.
sqlstore.sqlstoremanager.executeupdatebatch=--> SQLStoreManager.executeUpdateBatch().
sqlstore.sqlstoremanager.getpersistenceconfig=<--> SQLStoreManager.getPersistenceConfig(), classType = {0}.
sqlstore.sqlstoremanager.selectnoncorrelated.exit=<-- SQLStoreManager.selectNonCorrelated().
sqlstore.sqlstoremanager.selectnoncorrelated=--> SQLStoreManager.selectNonCorrelated().
sqlstore.sqlstoremanager.vendortype=<--> SQLStoreManager: tipo di fornitore = {0}.


###############################################################################
# <Connection/Connectionpool/DBVendorType/TransactionImpl/OracleSpecialDBOperation>
# Message ID Range: JDO76500 - JDO76599
###############################################################################
#
# <Connection/Connection Pool> - database
#
connection.connectionmanager.badnew=JDO76500: nuovo/a ''{0}'' deve essere maggiore o uguale al/alla ''{1}'' corrente.
connection.connectionmanager.badvalue=JDO76501: valore non valido per ''{0}''.
connection.connectionmanager.conntimeout=JDO76502: timeout di connessione scaduto.
connection.connectionmanager.getconnection.mismatch=JDO76503: la connessione in pool non ha lo stesso contesto utente.
connection.connectionmanager.isdown=JDO76504: Connection Manager in fase di chiusura.
connection.connectionmanager.maxpool=JDO76505: connection pool al massimo.
connection.connectionmanager.msintervalvalue=JDO76506: MsInterval deve essere maggiore di zero e minore o uguale a MsWait.
connection.connectionmanager.mswaitvalue=JDO76507: MsWait deve essere maggiore o uguale a zero.
connection.connectionmanager.nulldriver=JDO76508: valore nullo per il nome driver.
connection.connectionmanager.nullurl=JDO76509: valore nullo per l'URL.
connection.connectionmanager.poolsize=JDO76510: 'maxPool' deve essere maggiore o uguale a 'minPool'.
connection.connectionmanager.threaditerupted=JDO76511: thread interrotto.
connection.connectionmanager.zero=JDO76512: ''{0}'' deve essere maggiore o uguale zero.
#
# <DBVendorType>
#
sqlstore.database.dbvendor.cantloadDefaultProperties=JDO76513: impossibile caricare le propriet\u00E0 per il database predefinito.
sqlstore.database.dbvendor.init.default=JDO76514: --> Impossibile caricare la propriet\u00E0 per il tipo di fornitore {0}. Verranno utilizzati i valori predefiniti.
sqlstore.database.dbvendor.cantinstantiateclass=JDO76515: creazione di un''istanza della classe {0} non riuscita.
#
# <OracleSpecialDBOperation>
#
sqlstore.database.oracle.defineCol=JDO76516: definizione della colonna per l'istruzione non riuscita.
sqlstore.database.oracle.nooracleavailable=JDO76517: impossibile ottenere un''istanza di oracle.jdbc.OraclePreparedStatement o oracle.jdbc.driver.OraclePreparedStatement durante l''inizializzazione del resource factory Oracle ''{0}''. L''ottimizzazione specifica Oracle verr\u00E0 disabilitata. Se le istanze che usano questa risorsa richiedono valori di associazione per le colonne mappate alla colonna Fixed Char, verr\u00E0 eseguita l''aggiunta di spazi nei valori fino a ottenere la lunghezza specificata nel file dbschema corrispondente.
sqlstore.database.oracle.fixedcharpadded=JDO76518: il valore "{0}" \u00E8 associato a una colonna CHAR. Ci\u00F2 richiede una gestione speciale in Oracle. Poich\u00E9 \u00E8 impossibile ottenere la classe OraclePreparedStatement dal driver, viene eseguita l''aggiunta di spazi nel valore fino a ottenere la lunghezza {1} specificata nel file dbschema acquisito.
#
# <Misc.>
#
core.configuration.getvendortypefailed=JDO76519: identificazione del tipo di fornitore per il data store non riuscita.
jdo.sqlpersistencemanagerfactory.errorgettingDatabaseInfo=JDO76520: errore durante il tentativo di ottenere informazioni sul database. Rilevata l'eccezione seguente:

#
# <NOI18N: Connection>
#
sqlstore.connection.conncectiomgr.found=<--> ConnectionManager.getConnection: {0} trovata.
sqlstore.connection.conncectiomgr.getnewconn=<--> ConnectionManager.getConnection: {0} nuova.
sqlstore.connection.conncectiomgr.replacefreeconn=<--> ConnectionManager.replaceFreeConnection: {0} libera.
sqlstore.connectionimpl.clearxact.close=--- ConnectionImpl.clearXact: connessione chiusa.
sqlstore.connectionimpl.clearxact.disassocxact=--- ConnectionImpl.clearXact: disassociateXact.
sqlstore.connectionimpl.clearxact=--- ConnectionImpl.clearXact:.
sqlstore.connectionimpl.close.connrelease=<--- ConnectionImpl.close: connessione rilasciata.
sqlstore.connectionimpl.close.exit=<--- ConnectionImpl.close: connessione chiusa.
sqlstore.connectionimpl.close.freepending=<--- ConnectionImpl.close: impostazione di FreePending.
sqlstore.connectionimpl.close.putfreelist=<--- ConnectionImpl.close: inserimento in freeList.
sqlstore.connectionimpl.close.replaced=<--- ConnectionImpl.close: connessione sostituita.
sqlstore.connectionimpl.close=---> ConnectionImpl.close.
sqlstore.connectionimpl.close_arg=---> ConnectionImpl.close: {0}.
sqlstore.connectionimpl.commit=--- ConnectionImpl.commit: connessione chiusa.
sqlstore.connectionimpl.finalize=--- ConnectionImpl.finalize: connessione chiusa.
sqlstore.connectionimpl.internalcommit=--- ConnectionImpl.internalCommit:.
sqlstore.connectionimpl.pendingdisassocxact=--- ConnectionImpl.clearXact: disassociateXact in sospeso.
sqlstore.connectionimpl.rollback.close=--- ConnectionImpl.rollback: connessione chiusa.
sqlstore.connectionimpl.rollback=--- ConnectionImpl.rollback:.
#
# <NOI18N: DBVendorType>
#
sqlstore.database.dbvendor.castRequiredForNumericValues=<-> DBVendorType.isCastRequiredForNumericValues(): {0}.
sqlstore.database.dbvendor.getModFunctionName=<-> DBVendorType.getModFunctionName(): {0}.
sqlstore.database.dbvendor.getNullComparisonFunctionName=<-> DBVendorType.getNullComparisonFunctionName(): {0}.
sqlstore.database.dbvendor.getConcatCast=<-> DBVendorType.getConcatCast(): {0}.
sqlstore.database.dbvendor.getSpecialDBOperation=<-> DBVendorType.getSpecialDBOperation(): {0}.
sqlstore.database.dbvendor.getabs=<-> DBVendorType.getAbs(): {0}.
sqlstore.database.dbvendor.getcharlength=<-> DBVendorType.getCharLength(): {0}.
sqlstore.database.dbvendor.getforupdate=<-> DBVendorType.getForUpdate(): {0}.
sqlstore.database.dbvendor.getholdlock=<-> DBVendorType.getHoldlock(): {0}.
sqlstore.database.dbvendor.getisnotnull=<-> DBVendorType.getIsNotNull(): {0}.
sqlstore.database.dbvendor.getisnull=<-> DBVendorType.getIsNull(): {0}.
sqlstore.database.dbvendor.getleftjoin=<-> DBVendorType.getLeftJoin(): {0}.
sqlstore.database.dbvendor.getleftjoinpost=<-> DBVendorType.getLeftJoinPost(): {0}.
sqlstore.database.dbvendor.getleftlikeescape=<-> DBVendorType.getLeftLikeEscape(): {0}.
sqlstore.database.dbvendor.getnotequal=<-> DBVendorType.getNotEqual(): {0}.
sqlstore.database.dbvendor.getposition3args=<-> DBVendorType.getPositionThreeArrgs(): {0}.
sqlstore.database.dbvendor.getposition=<-> DBVendorType.getPosition(): {0}.
sqlstore.database.dbvendor.getpositionin=<-> DBVendorType.getPositionIn(): {0}.
sqlstore.database.dbvendor.getpositionsrchsrc=<-> DBVendorType.getPositionSearchSource(): {0}.
sqlstore.database.dbvendor.getquotecharstart=<-> DBVendorType.getQuoteCharStart(): {0}.
sqlstore.database.dbvendor.getrightjoinipre=<-> DBVendorType.getRightJoin(): {0}.
sqlstore.database.dbvendor.getrightlikeescape=<-> DBVendorType.getRightLikeEscape(): {0}.
sqlstore.database.dbvendor.getrtrim=<-> DBVendorType.getRtrim(): {0}.
sqlstore.database.dbvendor.getrtrimpost=<-> DBVendorType.getRtrimPost(): {0}.
sqlstore.database.dbvendor.getsqrt=<-> DBVendorType.getSqrt(): {0}.
sqlstore.database.dbvendor.getstringconcat=<-> DBVendorType.getStringConcat(): {0}.
sqlstore.database.dbvendor.getsubstring=<-> DBVendorType.getSubstring(): {0}.
sqlstore.database.dbvendor.getsubstringfor=<-> DBVendorType.getSubstringFor(): {0}.
sqlstore.database.dbvendor.getsubstringfrom=<-> DBVendorType.getSubstringFrom(): {0}.
sqlstore.database.dbvendor.gettablelistend=<-> DBVendorType.getTableListEnd(): {0}.
sqlstore.database.dbvendor.gettableliststart=<-> DBVendorType.getTableListStart(): {0}.
sqlstore.database.dbvendor.isAnsiTrim=<-> DBVendorType.isAnsiTrim(): {0}.
sqlstore.database.dbvendor.isInlineNumeric=<-> DBVendorType.isInlineNumeric(): {0}.
sqlstore.database.dbvendor.isNativeOuterJoin=<-> DBVendorType.isNativeOuterJoin(): {0}.
sqlstore.database.dbvendor.isParameterCast=<-> DBVendorType.isParameterCast(): {0}.
sqlstore.database.dbvendor.isdistinctupdatelocksupported=<-> DBVendorType.isDistinctSupportedWithUpdateLock(): {0}.
sqlstore.database.dbvendor.islockcolumnlistsupported=<-> DBVendorType.isLockColumnListSupported(): {0}.
sqlstore.database.dbvendor.isupdatelocksupported=<-> DBVendorType.isUpdateLockSupported(): {0}.
sqlstore.database.dbvendor.mapemptystrtonull=<-> DBVendorType.mapEmptyStringToNull(): {0}.
sqlstore.database.dbvendor.overrideproperties.with=<-> DBVendorType.overrideProperties() : {0} con: {1}.
sqlstore.database.dbvendor.overrideproperties=<-> DBVendorType.overrideProperties() - Nessuno.
sqlstore.database.dbvendor.supportslikeescape=<-> DBVendorType.supportsLikeEscape(): {0}.
sqlstore.database.dbvendor.vendorname=<-> DBVendorType(), vendorName: [{0}]  vendorType: {1}.
#
# <NOI18N: TransactionImpl>
#
sqlstore.transactionimpl.call.info={0} Tran[ {1} ].{2}: {3} for  {4}.
sqlstore.transactionimpl.call={0} Tran[ {1} ].{2}:status = {3}, txType: {4} for  {5}.
sqlstore.transactionimpl.closeconnection=--- TransactionImpl.closeConnection() {0} for {1}.
sqlstore.transactionimpl.general={0}.
sqlstore.transactionimpl.getconnection=--- TransactionImpl.getConnection(): {0} TX optimistic: {1} referenceCount = {2} for {3}.
sqlstore.transactionimpl.releaseconnection=--- TransactionImpl.releaseConnection(): TX optimistic: {0} Inside Commit: {1} referenceCount: {2} for {3}.
sqlstore.transactionimpl.rollbackconnection=--- TransactionImpl.rollbackConnection(): {0} for {1}.
sqlstore.transactionimpl.status={0} Tran[ {1} ].setStatus: {2} => {3} for {4}.


###############################################################################
# All the source files under subdir ejb.
# Message ID Range: JDO76600 - JDO76699
###############################################################################
#
#EJBHelper messages
#
# {0} - method name
ejb.ejbhelper.nonmanaged=JDO76600: il metodo {0} non deve essere invocato in un ambiente non gestito.

#
# Common messages between SunContainerHelper and DeploymentHelper
# so they have a neutral key, that still starts with "ejb".
#
# {0} - jndi name.
ejb.jndi.lookupfailed=JDO76604: ricerca JNDI della risorsa CMP ''{0}'' non riuscita.
JDO76604.diag.cause.1=La risorsa CMP con il nome JNDI specificato non \u00E8 registrata con questa istanza.
JDO76604.diag.cause.2=Ortografia errata del nome JNDI per la risorsa CMP.
JDO76604.diag.check.1=Controllare il nome JNDI per la risorsa che si intende usare.
JDO76604.diag.check.2=Controllare il nome JNDI della risorsa CMP specificata nel modulo.

# {0} - jndi name.
# {1} - returned class name.
ejb.jndi.unexpectedinstance=JDO76605: la ricerca JNDI della risorsa CMP ''{0}'' ha restituito un''istanza di tipo imprevisto: {1}.
JDO76605.diag.cause.1=La risorsa CMP con questo nome JNDI non fa riferimento alla risorsa JDBC o alla risorsa persistence-manager-factory.
JDO76605.diag.cause.2=Ortografia errata del nome JNDI per la risorsa CMP.
JDO76605.diag.check.1=Controllare il nome JNDI per la risorsa che si intende usare.
JDO76605.diag.check.2=Controllare il nome JNDI della risorsa CMP specificata nel modulo.

#
# DeploymentHelper messages - ejb
#
#
#<NOI18N: DeploymentHelper>
#
ejb.DeploymentHelper.getconnection=Recupero della connessione per il nome JNDI ''{0}''.

# The messages JDO76606 through JDO76615 that were originally here 
# have been moved to 
# cmp/support/ejb/src/com/sun/jdo/spi/persistence/support/ejb/ejbc/Bundle.properties
# As part of INF#
# So do not use these messages. 


#
#CMPHelper messages
#
ejb.cmphelper.nonmanaged=JDO76613: accesso non valido di CMPHelper. Questa classe \u00E8 utilizzata solo per il supporto CMP e non deve essere invocata fuori da un Application Server.

#
#SunTransactionHelper messages
#

# {0} class name
ejb.SunTransactionHelper.wrongdatasourcetype=JDO76616: DataSource non del tipo previsto. Previsto: com.sun.appserv.jdbc.DataSource, ottenuto: {0}.


###############################################################################
# <Generic messages. Add new messages to this section only if none of the above categories can be used.>
###############################################################################
#
# <NOI18N: generic>
#
vendor=Sun Microsystems
# majorVersion (minorVersion) buildDate
fullVersion={0} ({1}) {2}
#
# <NOI18N: This messages are used for JDOFatalInternalException from multiple places. No need to I18N>
#
core.generic.unknownfield=Il campo {0} non \u00E8 membro della classe {1}.
core.generic.unknownexception=Ricevuta un'eccezione sconosciuta.
core.generic.nullparam=Il parametro {0} \u00E8 nullo.
core.generic.notinstanceof=L''oggetto della classe {0} non \u00E8 un''istanza di {1}.


###############################################################################
# <These messages are used from multiple places in code.It is absolutely necessary to cleanup code
# to use different messages >
###############################################################################
core.configuration.cantloadclass=Caricamento della classe {0} non riuscito.
sqlstore.exception.log=Eccezione.
jdo.lifecycle.deleted.accessField=Impossibile accedere al campo di un'istanza eliminata.
