#
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
#
# Copyright (c) 1997-2017 Oracle and/or its affiliates. All rights reserved.
#
# The contents of this file are subject to the terms of either the GNU
# General Public License Version 2 only ("GPL") or the Common Development
# and Distribution License("CDDL") (collectively, the "License").  You
# may not use this file except in compliance with the License.  You can
# obtain a copy of the License at
# https://oss.oracle.com/licenses/CDDL+GPL-1.1
# or LICENSE.txt.  See the License for the specific
# language governing permissions and limitations under the License.
#
# When distributing the software, include this License Header Notice in each
# file and include the License file at LICENSE.txt.
#
# GPL Classpath Exception:
# Oracle designates this particular file as subject to the "Classpath"
# exception as provided by Oracle in the GPL Version 2 section of the License
# file that accompanied this code.
#
# Modifications:
# If applicable, add the following below the License Header, with the fields
# enclosed by brackets [] replaced by your own identifying information:
# "Portions Copyright [year] [name of copyright owner]"
#
# Contributor(s):
# If you wish your version of this file to be governed by only the CDDL or
# only the GPL Version 2, indicate your decision by adding "[Contributor]
# elects to include this software in this distribution under the [CDDL or GPL
# Version 2] license."  If you don't indicate a single choice of license, a
# recipient has the option to distribute your version of this file under
# either the CDDL, the GPL Version 2 or to extend the choice of license to
# its licensees as provided above.  However, if you add GPL Version 2 code
# and therefore, elected the GPL Version 2 license, then the option applies
# only if the new code is made subject to such option by the copyright
# holder.
#

# Resource bundle for sqlstore runtime messages
# key consists of: <subpackage>.<class>.<method>.<description>
# <subpackage> - is optional, package under runtime
# <class> - class name
# <method> - method name
# <description> - short description (use _ to represent space)
# all keys should be in lowercase
#
# Please note that many package names and classnames have changed over time.
# Unfortunately, this file was not maintained to follow above convention.
# Please ignore if the package/class name does not match actual names as today.
#
#
# The message ID for a message in persistence is derived as follows:
# JDO<2_digit_bundle_prefix><1_digit_section_number><2_digit_serial_number>
#
# The 2 digit prefix for this bundle is 76.
#
# This file is divided into the following sections:
# Under each section, messages that need not be I18Ned are separated under NOI18N. All other messages
# need to be numbered.
# 1. JDO:  PersistenceManagerFactory/PersistenceManager/ExtentCollection/LifeCycle
# 2. Model
# 3. StateManager
# 4. sql generator components: RetrieveDesc, ResultDesc plus all the files under generator subdir
# 5. SQLStoreManager
# 6. Connection/Connectionpool/Transaction/DBVendorType
# 7. EJB integration.
# 8. Generic messages.
#
# When adding a new message:
# 1. Please make sure that you add the message to the end of appropriate section.
# 2. Please add message ID to any user visible message.
# 3. The message ID for the new message = message ID for the last numbered
#    message in a section + 1.
# 4. Please do not change the message ID for existing messages. These
#    numbers are potentially mapped to more explanation about the message for
#    the end user.
#

####################################################################################################
# <All the source files under subdir impl (PersistenceManagerFactory/PersistenceManager etc.) >
# Message ID Range: JDO76000 - JDO76099
####################################################################################################
jdo.persistencemanagerfactoryimpl.getpersistencemanager.error=JDO76000 : impossible d'utiliser des combinaisons multiples nom utilisateur/mot de passe dans la m\u00EAme transaction.
jdo.persistencemanagerfactoryimpl.getpersistencemanager.notconfigured=JDO76001 : PersistenceManagerFactory n'est pas configur\u00E9.
jdo.persistencemanagerfactoryimpl.notsupported=JDO76002 : l'op\u00E9ration n'est pas prise en charge pour l'\u00E9l\u00E9ment PersistenceManagerFactoryImpl interne.
jdo.persistencemanagerimpl.acquireexclusivelock.interrupted=JDO76003 : \u00E9chec de l'obtention d'un verrou exclusif en raison d'une exception InterruptedException.
jdo.persistencemanagerimpl.acquiresharelock.failed=JDO76004 : \u00E9chec de l'obtention d'un verrou partag\u00E9 car la valeur _readWritecount est inf\u00E9rieure \u00E0 z\u00E9ro
jdo.persistencemanagerimpl.acquiresharelock.interrupted=JDO76003 : \u00E9chec de l'obtention d'un verrou partag\u00E9 en raison d'une exception InterruptedException.
jdo.persistencemanagerimpl.another_pm=JDO76006 : l'objet est associ\u00E9 \u00E0 un autre gestionnaire PersistenceManager.
jdo.persistencemanagerimpl.assertactivetransaction.error=JDO76007 : la transaction associ\u00E9e \u00E0 ce gestionnaire de persistance n'est pas active.
jdo.persistencemanagerimpl.assertclosed.closed=JDO76008 : PersistenceManager est ferm\u00E9.
jdo.persistencemanagerimpl.assertpersistencecapable.error=JDO76009 : la classe {0} n''a pas \u00E9t\u00E9 enrichie pour la persistance transparente. Utilisez l''outil de packaging JAR ou WAR de IDE pour packager vos classes capables de persistance avant l''ex\u00E9cution. Vous pouvez \u00E9galement d\u00E9finir la propri\u00E9t\u00E9 de l''ex\u00E9cuteur de la classe principale sur Ex\u00E9cuteur de persistance afin qu''elle fonctionne \u00E0 partir de l''IDE.
jdo.persistencemanagerimpl.close.activetransaction=JDO76010 : il existe une transaction ouverte associ\u00E9e \u00E0 ce gestionnaire de persistance.
jdo.persistencemanagerimpl.fetchinstance.none=JDO76012 : objet introuvable pour cet ID objet.
jdo.persistencemanagerimpl.internaldeletepersistent.transient=JDO76014 : impossible de supprimer un objet non persistant.
jdo.persistencemanagerimpl.internalmakepersistent.dups=JDO76015 : une instance poss\u00E9dant la m\u00EAme cl\u00E9 primaire existe d\u00E9j\u00E0 dans ce cache PersistenceManager.
jdo.persistencemanagerimpl.loadclassforoid.wrongoidclass=JDO76016 : erreur lors de l'extraction de l'objet Classe \u00E0 partir d'OID.
jdo.persistencemanagerimpl.newscoinstance.wrongclass=JDO76017 : impossible de cr\u00E9er une instance SCO de la classe {0} car elle n''est pas d''un type valide.
jdo.persistencemanagerimpl.notprocessed=JDO76018 : impossible de se d\u00E9barrasser des instances persistantes en raison des d\u00E9pendances circulaires.
jdo.persistencemanagerimpl.releaseexclusivelock.failed=JDO76019 : \u00E9chec de la lib\u00E9ration d'un verrou exclusif car la valeur _readWriteCount est sup\u00E9rieure \u00E0 z\u00E9ro.
jdo.persistencemanagerimpl.releasesharelock.failed=JDO76020 : \u00E9chec de la lib\u00E9ration d'un verrou partag\u00E9 car la valeur _readWriteCount est \u00E9gale \u00E0 z\u00E9ro.
jdo.persistencemanagerwrapper.invalidpm=JDO76021 : PersistenceManagerWrapper est ferm\u00E9.
jdo.extentcollection.constructor.invalidclass=JDO76022 : classe non valide ''{0}'' pour la collection d''extents.
jdo.extentcollection.constructor.nonpc=JDO76023 : la classe ''{0}'' n''est pas capable de persistance.
jdo.extentcollection.constructor.subclasses=JDO76024 : les sous-classes d'option true ne sont pas prises en charge pour les collections d'extents.
jdo.extentcollection.illegalmodification=JDO76025 : modification interdite de la collection d''extents pour la classe ''{0}''.
jdo.extentcollection.methodnotsupported=JDO76026 : la m\u00E9thode de collection d''extents {0} n''est pas prise en charge.
jdo.lifecycle.xactnotactive=JDO76027 : une transaction active est requise pour r\u00E9aliser cette op\u00E9ration.
jdo.persistencemanagerimpl.newinstance.badsm=JDO76028 : StateManager n'est pas totalement configur\u00E9.
jdo.persistencemanagerimpl.setjtatransaction.notnulljta=JDO76029 : tentative de remplacement de la transaction non NULL javax.transaction.Transaction : {0} par {1}.
jdo.persistencemanagerfactoryimpl.getpersistencemgr.closed=JDO76030 : le gestionnaire PersistenceManager pour la transaction javax.transaction.Transaction : {0} est d\u00E9j\u00E0 ferm\u00E9 ou en cours de validation.
jdo.persistencemanagerfactoryimpl.registerpm.registered=JDO76031 : l''instance de javax.transaction.Transaction : {0} est d\u00E9j\u00E0 inscrite dans un autre PersistenceManager : {1}.
jdo.persistencemanagerimpl.verificationfailed=JDO76032 : l'instance de coh\u00E9rence de la version n'a pas pu effectuer la v\u00E9rification avec la banque de donn\u00E9es.
jdo.persistencemanagerfactoryimpl.getversionconsistencycache.nullstore=JDO76033 : StoreManager n'est pas configur\u00E9.

#
# <NOI18N: LifeCycle>
#
sqlstore.state.lifecyclestate.changestate=LifeCycleState.changeState(), ancien \u00E9tat = {0}, nouvel \u00E9tat = {1}.
sqlstore.state.lifecyclestate.initial=LifeCycleState.getLifeCycleState(), \u00E9tat initial = {0}.

#
# <NOI18N: PersistenceManager>
#
sqlstore.persistencemgr.acquireexclusivelock.count=acquireExclusiveLock(), thread {0} avec _readWriteCount = {1}.
sqlstore.persistencemgr.acquireexclusivelock=acquireExclusiveock(), le thread {0} va attendre.
sqlstore.persistencemgr.acquiresharedlock.rdwrcount=acquireShareLock(), le thread {0} a acquis un verrou partag\u00E9 avec _readWriteCount ={1}.
sqlstore.persistencemgr.acquiresharedlock=acquireShareLock(), le thread {0} va attendre.
sqlstore.persistencemgr.aftercompletion.process=---PersistenceManagerImpl.afterCompletion() process: {0}.
sqlstore.persistencemgr.aftercompletion=---PersistenceManagerImpl.afterCompletion() abort: {0}.
sqlstore.persistencemgr.assertactivetx.closed=--- PersistenceManagerImpl.assertActiveTransaction: Closed for  {0}.
sqlstore.persistencemgr.assertactivetx=--- PersistenceManagerImpl.assertActiveTransaction: {0}.
sqlstore.persistencemgr.assertisopen=--- PersistenceManagerImpl.assertIsOpen: Closed for {0}.
sqlstore.persistencemgr.beforecompletion=---PersistenceManagerImpl.beforeCompletion().
sqlstore.persistencemgr.cacheproperties=Propri\u00E9t\u00E9s de cache PersistenceManagerImpl : _txCacheInitialCapacity={0}, _flushedCacheInitialCapacity={1}, _flushedCacheLoadFactor={2}, _weakCacheInitialCapacity={3}, _weakCacheLoadFactor={4}.
sqlstore.persistencemgr.deregisterinstance.verified=---PersistenceManagerImpl.deregisterInstance() -- deregistered with verify.
sqlstore.persistencemgr.deregisterinstance.verify=---PersistenceManagerImpl.deregisterInstance() with verify SM -- oid: {0}  for PersistenceManager: {1}  and JTA: {2}.
sqlstore.persistencemgr.deregisterinstance=---PersistenceManagerImpl.deregisterInstance() oid: {0}  for PersistenceManager: {1}  and JTA: {2}.
sqlstore.persistencemgr.getbyobjid=---PersistenceManagerImpl.getObjectById() OID:{0}  for PersistenceManager: {1} and JTA: {2}.
sqlstore.persistencemgr.getcurrentwrapper=---PersistenceManagerImpl.getCurrentWrapper() > current: {0}.
sqlstore.persistencemgr.getobjid.notpc=---PersistenceManagerImpl.getObjectId() NOT PC: {0}  for PersistenceManager: {1}.
sqlstore.persistencemgr.getobjid.notpm=---PersistenceManagerImpl.getObjectId() NOT PM: {0} for PersistenceManager: {1}  and JTA: {2}.
sqlstore.persistencemgr.getobjid= :{0} ---PersistenceManagerImpl.getObjectId() PC: {1} for PersistenceManager: {2} and JTA: {3}.
sqlstore.persistencemgr.internalcloneoid.old=---PersistenceManagerImpl.internalCloneOid(): old: {0}  new: {1} same: {2}.
sqlstore.persistencemgr.internalcloneoid=---PersistenceManagerImpl.internalCloneOid() error: {0}.
sqlstore.persistencemgr.isactivetx=---PersistenceManagerImpl.isActiveTransaction() : {0}.
sqlstore.persistencemgr.isnontxread=---PersistenceManagerImpl.isNontransactionalRead() : {0}.
sqlstore.persistencemgr.isoptimistic=---PersistenceManagerImpl.isOptimisticTransaction() : {0}.
sqlstore.persistencemgr.loadingclass=Chargement... Nom de classe : {0}.
sqlstore.persistencemgr.loadingfile=Chargement... Nom de fichier : {0} {1} {2}.
sqlstore.persistencemgr.makepersistent.done=---PersistenceManagerImpl.makePersistent() {0}  finished for: {1}  and JTA: {2}.
sqlstore.persistencemgr.makepersistent= {0} ---PersistenceManagerImpl.makePersistent() PC: {1} for PersistenceManager: {2} and JTA: {3}.
sqlstore.persistencemgr.newcollection=---PersistenceManagerImpl.newCollectionInstanceInternal() type: {0}.
sqlstore.persistencemgr.popcurrentwrapper=---PersistenceManagerImpl.popCurrentWrapper() > current: {0}  prev: {1}.
sqlstore.persistencemgr.pushcurrentwrapper=---PersistenceManagerImpl.pushCurrentWrapper() > current: {0}  new: {1}.
sqlstore.persistencemgr.registerinstance= {0} ---PersistenceManagerImpl.registerInstance() oid/sm: {1}/{2}  for PersistenceManager: {3}  and JTA: {4}.
sqlstore.persistencemgr.registerinstancein_txc=registerInstance in TXC :{0} / {1} for PersistenceManager: {2} and JTA: {3}.
sqlstore.persistencemgr.registerinstancein_wkc=registerInstance in WKC.
sqlstore.persistencemgr.releaseexclusivelock=releaseExclusiveock(), thread {0} avec _readWriteCount = {1}.
sqlstore.persistencemgr.releasesharedlock=releaseShareLock(), thread {0} avec _readWriteCount = {1}.
sqlstore.persistencemgr.replacingdeletedinstance=Remplacement de l''instance supprim\u00E9e par une nouvelle instance pour l''ID d''objet : {0}.
sqlstore.persistencemgr.setkeyfields=---PersistenceManagerImpl.setKeyFields() error: {0}.
#
# <NOI18N: PersistenceManagerFactory>
#
sqlstore.sqlpersistencemgrfactory.getfrompool.pmt=<--SQLPersistenceManagerFactory.getFromPool() PM: {0} for JTA {1}.
sqlstore.sqlpersistencemgrfactory.getfrompool=<--SQLPersistenceManagerFactory.getFromPool().
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.found= {0} <->SQLPersistenceManagerFactory.getPersistenceManager() found javax.transaction.Transaction: {1}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.jdotx.notfound=<->SQLPersistenceManagerFactory.getPersistenceManager() not found JDO Transaction.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.jdotx=<->SQLPersistenceManagerFactory.getPersistenceManager() JDO Transaction: {0}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.pmclosedfor= {0} <->SQLPersistenceManagerFactory.getPersistenceManager() PM is closed for: {1}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.pmt= {0} <->SQLPersistenceManagerFactory.getPersistenceManager() : {1} for JTA: {2}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr=:{0} -->SQLPersistenceManagerFactory.getPersistenceManager().
sqlstore.sqlpersistencemgrfactory.init=---SQLPersistenceManagerFactory.initialize().
sqlstore.sqlpersistencemgrfactory.pmCacheBucketSize=---SQLPersistenceManagerFactory pmCacheBucketSize = {0}.
sqlstore.sqlpersistencemgrfactory.pmCacheInitialCapacity=---SQLPersistenceManagerFactory pmCacheInitialCapacity = {0}.
sqlstore.sqlpersistencemgrfactory.registerpersistencemgr.pmt=<->SQLPersistenceManagerFactory.registerPersistenceManager() PM: {0} for JTA Tx: {1}.
sqlstore.sqlpersistencemgrfactory.releasepm.pmt=---SQLPersistenceManagerFactory.releasePersistenceManager() PM:{0} for JTA Tx: {1}.
sqlstore.sqlpersistencemgrfactory.returnToPool=<--SQLPersistenceManagerFactory.returnToPool().


###############################################################################
# <Model>
# Message ID Range: JDO76100 - JDO76199
###############################################################################
core.configuration.columnnotable=JDO76100 : le descripteur de colonne ne poss\u00E9dait pas de descripteur de table valide.
core.configuration.fieldnotable=JDO76101 : le champ {0} n''est associ\u00E9 \u00E0 aucune table.
core.configuration.fieldnotmapped=JDO76102 : le champ persistant {0} pour la classe {1} n''est pas mapp\u00E9.
core.configuration.iddescnofield=JDO76103 : l'objet SqlIDDesc n'a pas \u00E9t\u00E9 d\u00E9fini correctement. Les descripteurs de champ ne sont pas disponibles.
core.configuration.loadfailed.class=JDO76104 : \u00E9chec du chargement de la configuration pour la classe {0}.
core.configuration.noneexistentpkfield=JDO76105 : le champ {0} dans la classe ObjectId {1} n''existe pas dans la classe PersistenceCapable {2}.
core.configuration.unsupportedconsistencylevel=JDO76106 : le niveau de coh\u00E9rence de la classe {0} n''est pas pris en charge. Les niveaux de coh\u00E9rence pris en charge actuellement sont "none", "check-modified-at-commit", "lock-when-loaded" et "check-version-of-accessed-instances".
core.configuration.validationfailed=JDO76107 : le mapping pour la classe {0} n''est pas valide :\n{1}.
core.configuration.validationproblem=JDO76108 : erreur de validation dans la classe {0} : {1}
#
# <FieldDesc validation at runtime>
#
core.fielddesc.minvalue=JDO76109 : la valeur {0} est inf\u00E9rieure au minimum autoris\u00E9 ({1}) pour le type de champ {2}.
core.fielddesc.maxvalue=JDO76110 : la valeur {0} est sup\u00E9rieure au maximum autoris\u00E9 ({1}) pour le type de champ {2}.
core.configuration.noneexistentvcfield=JDO76111 : le champ {0} est d\u00E9fini comme champ de version, mais il ne figure pas dans la classe PersistenceCapable {1}.
core.configuration.loadfailed.field=JDO76112 : \u00E9chec du chargement de la configuration pour le champ {0} dans la classe {1}.

#
# <NOI18N: model>
#
sqlstore.model.classdesc.assocrelatedfield=champ de relation associ\u00E9 = {0}.
sqlstore.model.classdesc.createsqldesc=cr\u00E9ation de SqlIDDesc \u00E0 partir de {0}.
sqlstore.model.classdesc.fieldinfo=nom de champ = {0}, ID= {1}.
sqlstore.model.classdesc.general={0}.{1} =>{2}
sqlstore.model.classdesc.getlocalfielddesc=<-> SqlPersistenceDesc.getLocalFieldDesc(), classe ={0}, champ masqu\u00E9 ajout\u00E9 {1} pour la colonne {2}.
sqlstore.model.classdesc.loadedclass=Classe OID charg\u00E9e= {0}.
sqlstore.model.classdesc.persistconfiginit.exit=<-- SqlPersistenceConfig.initialize().
sqlstore.model.classdesc.persistconfiginit=--> SqlPersistenceConfig.initialize(), classe = {0}.
sqlstore.model.classdesc.pkfield=Champ de cl\u00E9 primaire = {0}.
sqlstore.model.classdesc.primarytrackedfield=le champ {0} est le champ suivi primaire.
sqlstore.model.classdesc.unsetconcurrencychk=annulation de la d\u00E9finition de la propri\u00E9t\u00E9 IN_CONCURRENCY_CHECK pour If {0}.
sqlstore.model.classdesc.unsetrefintegrityupdate=annulation de la d\u00E9finition de la propri\u00E9t\u00E9 REF_INTEGRITY_UPDATES pour ff {0}.
sqlstore.model.classdesc.vcfield=Champ de coh\u00E9rence de la version = {0}.
sqlstore.model.fielddesc.addingfield=ajout du champ {0} qui doit \u00EAtre suivi par le champ {1}.
sqlstore.model.fielddesc.convertvalue.from_to=convertValue : {0} de : {1} en : {2}.
sqlstore.model.fielddesc.convertvalue.hidden=convertValue : {0} masqu\u00E9e... renvoi.
sqlstore.model.fielddesc.convertvalue=convertValue : NULL... renvoi.
sqlstore.model.fielddesc.fieldname={0} = {1}.
sqlstore.model.fielddesc.setupdesc=setupDesc() : fieldName {0} fieldType {1}.
sqlstore.model.configcacheimpl.size_before=taille de {0} avant le nettoyage : {1}.
sqlstore.model.configcacheimpl.size_after=taille de {0} apr\u00E8s le nettoyage : {1}.


###############################################################################
# <StateManager>
# Message ID Range: JDO76200 - JDO76299
###############################################################################
core.statemanager.anotherowner=JDO76200 : impossible d'affecter une instance SCO qui appartient \u00E0 un autre objet.
core.statemanager.cantnewoid=JDO76201 : \u00E9chec de la cr\u00E9ation d''une instance de cl\u00E9 primaire de la classe {0}.
core.statemanager.cantschedulejointable=JDO76202 : impossible de planifier l''insertion de l''entr\u00E9e de la table entre la classe {0} et {1}, car la description du champ de relation est NULL.
core.statemanager.cantsetkeyfield=JDO76203 : \u00E9chec de la d\u00E9finition de la valeur du champ de cl\u00E9 primaire {0}.
core.statemanager.conflictingvalues=JDO76204 : conflit de valeurs entre les champs {0} et {1} qui sont mapp\u00E9s sur la m\u00EAme colonne.
core.statemanager.getfieldfailed=JDO76205 : \u00E9chec de l'obtention du champ.
core.statemanager.invalidpk=JDO76206 : champ de cl\u00E9 primaire NULL {0} incorrect lors du rechargement de la classe capable de persistance {1}. L''ObjectId de l''instance est {2}.
core.statemanager.nopkupdate=JDO76207 : la mise \u00E0 jour d'un champ de cl\u00E9 primaire n'est pas autoris\u00E9e.
core.statemanager.nopm=JDO76208 : le gestionnaire d'\u00E9tat ne contient pas de r\u00E9f\u00E9rence au gestionnaire de persistance.
core.statemanager.notnavigable=JDO76209 : une tentative d''acc\u00E8s au champ {0} de la classe {1} a \u00E9t\u00E9 effectu\u00E9e. Aucune instance de ce champ n''a \u00E9t\u00E9 cr\u00E9\u00E9e auparavant et cette classe ne permet pas la navigation dynamique. Vous devez adresser une demande sur ce champ lors de l''extraction de la classe ou permettre la navigation dynamique afin que ce champ puisse \u00EAtre extrait automatiquement en y acc\u00E9dant.
core.statemanager.objectnotfound=JDO76210 : l'objet n'existe pas dans la banque de donn\u00E9es.
core.statemanager.poshiddenindex=JDO76211 : l''index vers un champ masqu\u00E9 doit \u00EAtre n\u00E9gatif, mais cet index est \u00E9gal \u00E0 {0}.
core.statemanager.readonly=JDO76212 : une tentative de modification du champ en lecture seule {0} de la classe {1} a \u00E9t\u00E9 effectu\u00E9e.
core.statemanager.releaselock.wrongthread=JDO76213 : ce thread {0} n''a pas de verrou StateManager.
core.statemanager.setfieldfailed=JDO76214 : \u00E9chec de la d\u00E9finition du champ.
core.statemanager.wrongusageforoverlappingpkfkdelete=JDO76215 : tentative de suppression incorrecte d'une instance dans une relation g\u00E9r\u00E9e. La relation est d\u00E9finie par une colonne de cl\u00E9 primaire de l'autre c\u00F4t\u00E9. Une op\u00E9ration de suppression dans une collection implique la mise \u00E0 jour de la colonne de l'autre c\u00F4t\u00E9, et la mise \u00E0 jour des cl\u00E9s primaires n'est pas autoris\u00E9e. D\u00E8s lors, la suppression d'une instance dans une collection de relations g\u00E9r\u00E9es d\u00E9finie par une cl\u00E9 primaire est uniquement r\u00E9alisable en supprimant l'instance, explicitement ou par suppression en cascade.
core.statemanager.toomanyrows=JDO76215 : la requ\u00EAte a renvoy\u00E9 plus d''une ligne pour l''une des tables mapp\u00E9es sur la classe {0}. Chaque table mapp\u00E9e sur une classe devrait avoir uniquement une seule ligne pour chaque instance de l''objet.
core.statemanager.copyFields.mismatch=JDO76216 : tentative de copie de champs d''un StateManager vers un autre qui g\u00E8re des instances de plusieurs types : {0} et {1}.

#
# <NOI18N: StateManager>
#
sqlstore.sqlstatemanager.adddependency=<-> SQLStateManager.addDependency(), this StateManager: {0}, other StateManager: {1}.
sqlstore.sqlstatemanager.addupdate=<-> SQLStateManager.addUpdatedForeignReference(), lobj={0}, f={1}, fobj={2}, refCount={3}.
sqlstore.sqlstatemanager.applyupdates.exit=<-- SqlStateManager.applyUpdates().
sqlstore.sqlstatemanager.applyupdates=--> SqlStateManager.applyUpdates(), champ = {0}.
sqlstore.sqlstatemanager.clearpersistencefields.exit=<--- SqlStateManager.clearPersistenceFields().
sqlstore.sqlstatemanager.clearpersistencefields=--> SqlStateManager.clearPersistenceFields().
sqlstore.sqlstatemanager.copychanges.exit=<-- SQLStateManager.copyChanges().
sqlstore.sqlstatemanager.copychanges=--> SQLStateManager.copyChanges(), gestionnaire d''\u00E9tat = {0}.
sqlstore.sqlstatemanager.deletepersistence=<-> SqlStateManager.deletePersistence(), type = {0}.
sqlstore.sqlstatemanager.getbeforeimage.exit=<-- SqlStateManager.getBeforeImage().
sqlstore.sqlstatemanager.getbeforeimage=--> SqlStateManager.getBeforeImage(), type = {0}.
sqlstore.sqlstatemanager.isbeforeimagerequired=isBeforeImageRequired est : {0}.
sqlstore.sqlstatemanager.loadforread.exit=<-- SQLStateManager.loadForRead().
sqlstore.sqlstatemanager.loadforread=--> SQLStateManager.loadForRead().
sqlstore.sqlstatemanager.loadforupdate.exit=<-- SQLStateManager.loadForUpdate().
sqlstore.sqlstatemanager.loadforupdate=--> SQLStateManager.loadForUpdate().
sqlstore.sqlstatemanager.loggingfield=champ de journalisation = {0} avec la valeur = {1}.
sqlstore.sqlstatemanager.makedirty.fixscocollection=--- SqlStateManager.makeDirty(), fix SCOCollection.
sqlstore.sqlstatemanager.makedirty.fixscodate=--- SqlStateManager.makeDirty(), fix SCODate.
sqlstore.sqlstatemanager.makedirty=--> SqlStateManager.makeDirty(), champ = {0}.
sqlstore.sqlstatemanager.makedirtyfield=Marked dirty field = {0}.
sqlstore.sqlstatemanager.makepersistence=<-> SqlStateManager.makePersistence(), type = {0}.
sqlstore.sqlstatemanager.makepresent=--> SqlStateManager.makePresent(), champ = {0}.
sqlstore.sqlstatemanager.marking=marquage de {0} comme \u00E9tant pr\u00E9sent.
sqlstore.sqlstatemanager.newtype=Nouveau type : {0}.
sqlstore.sqlstatemanager.nosuchmethodexcep.clone=Exception : clone {0}... pour le type {1}.
sqlstore.sqlstatemanager.preparegetfield.exit=<-- SqlStateManager.prepareGetField().
sqlstore.sqlstatemanager.preparegetfield=--> SqlStateManager.prepareGetField(), nom = {0}.
sqlstore.sqlstatemanager.preparesetfield.exit=<-- SQLStateManager.prepareSetField().
sqlstore.sqlstatemanager.preparesetfield=--> SQLStateManager.prepareSetField(), nom = {0}.
sqlstore.sqlstatemanager.preparetoupdateph1.exit=<-- SqlStateManager.prepareToUpdateI().
sqlstore.sqlstatemanager.preparetoupdateph1=--> SqlStateManager.prepareToUpdatePhaseI(), type = {0}.
sqlstore.sqlstatemanager.preparetoupdateph2.exit=<-- SqlStateManager.prepareToUpdateII().
sqlstore.sqlstatemanager.preparetoupdateph2=--> SqlStateManager.prepareToUpdatePhaseII(), type = {0}.
sqlstore.sqlstatemanager.preparetoupdateph3.exit=<-- SqlStateManager.prepareToUpdateIII().
sqlstore.sqlstatemanager.preparetoupdateph3=--> SqlStateManager.prepareToUpdatePhaseIII(), type = {0}.
sqlstore.sqlstatemanager.prepareupdatefield.exit=<-- SQLStateManager.prepareUpdateField().
sqlstore.sqlstatemanager.prepareupdatefield=--> SQLStateManager.prepareUpdateField(), nom = {0} pour l''\u00E9tat {1}.
sqlstore.sqlstatemanager.prepareupdatefieldspl.exit=<-- SQLStateManager.prepareUpdateFieldSpecial().
sqlstore.sqlstatemanager.prepareupdatefieldspl=--> SQLStateManager.prepareUpdateFieldSpecial, nom = {0} pour l''\u00E9tat {1}.
sqlstore.sqlstatemanager.processcollectionupdate.exit=<-- SQLStateManager.processCollectionUpdates().
sqlstore.sqlstatemanager.processcollectionupdate=--> SQLStateManager.processCollectionUpdates(), beforeList={0}, afterlist={1}.
sqlstore.sqlstatemanager.processforeign=traiter le champ \u00E9tranger = {0}.
sqlstore.sqlstatemanager.processforeignfield.remove=-- SQLStateManager.processForeignField(): was Collection - remove.
sqlstore.sqlstatemanager.processforeignfield.remove_from_bi=-- SQLStateManager.processForeignField(): is SCOCollection - remove from BI.
sqlstore.sqlstatemanager.processforeignfield.reset=-- SQLStateManager.processForeignField(): was SCOCollection - reset.
sqlstore.sqlstatemanager.processforeignfield=-- SQLStateManager.processForeignField(): value: {0} type: {1}.
sqlstore.sqlstatemanager.realizefield.exit=<-- SqlStateManager.realizeField().
sqlstore.sqlstatemanager.realizefield=--> SqlStateManager.realizeField(), nom = {0}.
sqlstore.sqlstatemanager.realizeforeignfield.exit=<-- SqlStateManager.realizeField(), champ r\u00E9alis\u00E9 = {0}.
sqlstore.sqlstatemanager.realizeforeignfield=--> SqlStateManager.realizeField(), nom = {0}.
sqlstore.sqlstatemanager.recordingfield=enregistrement du champ = {0}.
sqlstore.sqlstatemanager.refreshpersistent.exit=<-- SqlStateManager.refreshPersistent().
sqlstore.sqlstatemanager.refreshpersistent=--> SqlStateManager.refreshPersistence(), type = {0}.
sqlstore.sqlstatemanager.reload.exit=<-- SqlStateManager.reload(FieldDesc).
sqlstore.sqlstatemanager.reload=--> SqlStateManager.reload(FieldDesc), type = {0}, champ = {1}.
sqlstore.sqlstatemanager.removeupdate=<-> SQLStateManager.removeUpdatedForeignReference(), lobj={0}, f={1}, fobj={2}, refCount={3}.
sqlstore.sqlstatemanager.replaceobjectfield.unsetsco=-- SqlStateManager.replaceObjectField(), unset SCO.
sqlstore.sqlstatemanager.replaceobjectfield=-- SqlStateManager.replaceObjectField(), field = {0}, type= {1}.
sqlstore.sqlstatemanager.reset=--> SqlStateManager.reset(), retValues = {0}, wasNew : {1}, keepState : {2}.
sqlstore.sqlstatemanager.resettingcollection=R\u00E9initialisation de la collection.
sqlstore.sqlstatemanager.resettingdate=R\u00E9initialisation de la date.
sqlstore.sqlstatemanager.resolvedependencies=<-> SQLStateManager.resolveDependencies(), obj={0}.
sqlstore.sqlstatemanager.resolvedependency=<-> SQLStateManager.resolveDependency(), d\u00E9pendance r\u00E9solue : lobj={0}, f={1}, fobj={2}.
sqlstore.sqlstatemanager.retrieve.exit=<-- SqlStateManager.retrieve().
sqlstore.sqlstatemanager.retrieve=--> SqlStateManager.retrieve(), nom = {0}.
sqlstore.sqlstatemanager.retrieveforeign.exit=<-- SqlStateManager.retrieveForeign().
sqlstore.sqlstatemanager.retrieveforeign=--> SqlStateManager.retrieveForeign(), nom = {0}.
sqlstore.sqlstatemanager.unsetmask=annulation de la d\u00E9finition des masques pour le champ = {0}.
sqlstore.sqlstatemanager.unconditionalreload.exit=<-- SqlStateManager.reload().
sqlstore.sqlstatemanager.unconditionalreload=--> SqlStateManager.reload(), type = {0}.
sqlstore.sqlstatemanager.updatebeforeimage=<-> SQLStateManager.updateBeforeImage(), nom = {0}, valeur = {1}.
sqlstore.sqlstatemanager.updateobjfield.exit=<-- SQLStateManager.updateObjectField().
sqlstore.sqlstatemanager.updateobjfield=--> SQLStateManager.updateObjectField(), nom = {0}, type = {1}.
sqlstore.sqlstatemanager.updatepersistent.exit=<-- SqlStateManager.updatePersistent().
sqlstore.sqlstatemanager.updatepersistent.immediateflush=<--> SqlStateManager.updatePersistent(), vidage imm\u00E9diat requis : obj={0}, next={1}.
sqlstore.sqlstatemanager.updatepersistent.skipped=<--> SqlStateManager.updatePersistent() non pris en compte, type={0}, obj={1}.
sqlstore.sqlstatemanager.updatepersistent=--> SqlStateManager.updatePersistent(), type = {0}.
sqlstore.sqlstatemanager.updatetrackedfields.exit=<-- updateTrackedFields().
sqlstore.sqlstatemanager.updatetrackedfields=--> updateTrackedFields(), f = {0} valeur = {1} fieldToIgnore = {2}.


###############################################################################
# <sql generator components: All the source files under sql.>
# Message ID Range: JDO76300 - JDO76399
###############################################################################
core.constraint.duporderby=JDO76300 : la contrainte est "order by" pour le champ {0} qui a d\u00E9j\u00E0 \u00E9t\u00E9 sp\u00E9cifi\u00E9 dans une contrainte "order by".
core.constraint.fielddisallowed=JDO76301\u00A0: le param\u00E8tre fieldName a \u00E9t\u00E9 d\u00E9fini mais il n''est pas autoris\u00E9 avec l''op\u00E9ration {0}.
core.constraint.fieldrequired=JDO76302 : le param\u00E8tre fieldName est absent mais l''op\u00E9ration {0} exige un champ.
core.constraint.illegalParameterInfo=JDO76303 : addConstraint() de OP_PARAMETER doit \u00EAtre appel\u00E9 avec la valeur de type ParameterInfo.
core.constraint.illegalnode=JDO76304 : noeud de contrainte {0} interdit dans la pile SqlConstraint.
core.constraint.illegalop=JDO76305 : le param\u00E8tre d''op\u00E9ration contenait une valeur interdite pour {0}.
core.constraint.needfieldnamenode=JDO76306 : erreur dans la pile de contraintes. Un nom de champ est attendu.
core.constraint.needfieldnode=JDO76307 : erreur dans la pile de contraintes. Une description de champ est attendue.
core.constraint.needvalnode=JDO76308 : erreur dans la pile de contraintes. Une valeur est attendue.
core.constraint.stackempty=JDO76309 : la pile de contraintes est vide. Il n'y a pas assez de valeurs pour le nombre d'op\u00E9rateurs.
core.constraint.unknownfield=JDO76310 : le champ {0} d\u00E9fini dans le descripteur d''extraction n''appartient pas \u00E0 la classe {1}.
core.constraint.valdisallowed=JDO76311\u00A0: le param\u00E8tre de valeur a \u00E9t\u00E9 d\u00E9fini mais il n''est pas autoris\u00E9 avec l''op\u00E9ration {0}.
core.constraint.valrequired=JDO76312 : le param\u00E8tre de valeur est manquant mais l''op\u00E9ration {0} exige une valeur.
sqlstore.resultdesc.errorgettingvalefromresulset=JDO76313 : erreur lors de l''obtention de la valeur \u00E0 partir de l''ensemble de r\u00E9sultats dans l''index {0} en tant que resultType {1}. columnSqlType {2}. Exception : {3}
sqlstore.resultdesc.foreignfieldprojection=JDO76314 : les requ\u00EAtes de {0} ne doivent pas avoir de projection sur un champ de relation.
sqlstore.resultdesc.unknownfieldtype=JDO76317 : type de champ inconnu {0} d\u00E9tect\u00E9.
sqlstore.retrievedesc.toomanyprojections=JDO76318 : impossible de d\u00E9finir plusieurs projections pour RetrieveDesc.
sqlstore.retrievedesc.toomanyresulttypes=JDO76319 : impossible de d\u00E9finir plusieurs types de r\u00E9sultat pour RetrieveDesc.
sqlstore.selectstatement.noupdatelocksupport=JDO76320 : l'un des types d'objet de cette requ\u00EAte a le niveau de coh\u00E9rence "lock-when-loaded". L'application de ce niveau de coh\u00E9rence implique que la banque de donn\u00E9es prenne en charge le verrouillage pour les mises \u00E0 jour au niveau des lignes. La banque de donn\u00E9es ne prend pas en charge le verrouillage pour les mises \u00E0 jour au niveau des lignes.
sqlstore.sql.generator.statement.likeescapenotsupported=JDO76321 : clause LIKE ESCAPE non prise en charge sur cette base de donn\u00E9es.
sqlstore.sql.generator.statement.positionthreeargsnotsupported=JDO76322 : le troisi\u00E8me argument pour la clause POSITION doit \u00EAtre 1.
core.configuration.classnotmapped=JDO76323 : la classe {0} n''est pas mapp\u00E9e.
core.configuration.classnotmappedtotable=JDO76324 : la classe {0} n''est pas mapp\u00E9e sur la table {1}.
sqlstore.sql.generator.statement.unexpectedconstraint=JDO76325 : une contrainte d''op\u00E9ration {0} ne peut jamais \u00EAtre la racine d''une clause where.

# <I18N: sql generator>
# Following messages are used within other messages. They need to be i18ned but need not be numbered.
#
sqlstore.sql.generator.statement.sqlStatement=Instruction SQL
sqlstore.sql.generator.statement.withinputvalues= valeurs d'entr\u00E9e :
sqlstore.sql.generator.statement.withnoinputvalues= aucune valeur en entr\u00E9e.


#
# <ResultDesc NOI18N>
#
sqlstore.resultdesc.deserializing=d\u00E9s\u00E9rialisation = {0}.
sqlstore.resultdesc.marking_field=marquage du champ local {0} comme \u00E9tant pr\u00E9sent.
sqlstore.resultdesc.marking_foreign_field=marquage du champ \u00E9tranger {0} comme \u00E9tant pr\u00E9sent.
sqlstore.resultdesc.marking_key_field=marquage du champ de cl\u00E9 {0} comme \u00E9tant pr\u00E9sent.
sqlstore.resultdesc.returning_field=renvoi du champ {0} en tant que projection.
#
# <Misc. SQLStore NOI18N >
#
sqlstore.sql.concurrency.concurrencychkdirty.exit=--> ConcurrencyCheckDirty.update().
sqlstore.sql.concurrency.concurrencychkdirty=--> ConcurrencyCheckDirty.update(), beforeImage = {0}.
sqlstore.sql.concurrencyoptverify.resumetx=<--> ConcurrencyOptVerify.resume(), transaction reprise = {0}.
sqlstore.sql.concurrencyoptverify.suspendtx=<--> ConcurrencyOptVerify.suspend(), transaction suspendue = {0}.
sqlstore.sql.concurrencyoptverify.update.exit=<-- ConcurrencyOptVerify.update().
sqlstore.sql.concurrencyoptverify.update=--> ConcurrencyOptVerify.update(), beforeImage = {0}.
sqlstore.sql.generator.dbstatement.addbatch=addbatch ({0})
sqlstore.sql.generator.dbstatement.bindinputcolumn=index bindInputColumn : {0}, valeur : {1}, sqlType : {2}.
sqlstore.sql.generator.dbstatement.executebatch=executeBatch ex\u00E9cutant {0} commandes
sqlstore.sql.generator.selectqueryplan.processforeignfield.exit=<-- SelectQueryPlan.processForeignFields().
sqlstore.sql.generator.selectqueryplan.processforeignfield=--> SelectQueryPlan.processForeignFields(), classe = {0}.
sqlstore.sql.generator.selectqueryplan.processlocalfield.exit=<-- SelectQueryPlan.processLocalFields().
sqlstore.sql.generator.selectqueryplan.processlocalfield=--> SelectQueryPlan.processLocalFields(), classe = {0}.
sqlstore.sql.generator.selectqueryplan.processstmts.exit=<-- SelectQueryPlan.processStatements().
sqlstore.sql.generator.selectqueryplan.processstmts=--> SelectQueryPlan.processStatements(), classe = {0}, instructions = {1}.
sqlstore.sql.updateobjdescimpl.afterimagenull=AfterImage n'est pas d\u00E9fini.
sqlstore.sql.updateobjdescimpl.beforeimagenull=BeforeImage n'est pas d\u00E9fini.
sqlstore.sql.updateobjdescimpl.markrelationshipchange=<--> UpdateDesc.markRelationshipChange().
sqlstore.sql.updateobjdescimpl.updated={0} est mis \u00E0 jour.


###############################################################################
# <SQLStoreManager>
# Message ID Range: JDO76400 - JDO76499
###############################################################################
#
# <SQLStoreManager>
#
core.persistencestore.jdbcerror=JDO76400 : exception SQLException JDBC lors de l''ex\u00E9cution de l''instruction SQL :\n{0}.\nPour plus d''informations, examinez le message de l''exception.
sqlstore.retrievedesc.stmntsnotjoined=JDO76401 : instructions SQL multiples non prises en charge pour RetrieveDesc.
core.persistencestore.toofewrows=JDO76402 : la tentative d''obtention \u00E0 partir de la base de donn\u00E9es de la valeur pour l''association {1} de la classe {0} a renvoy\u00E9 un nombre de lignes inf\u00E9rieur au nombre autoris\u00E9 par la cardinalit\u00E9 de cette association. Le nombre minimal de lignes autoris\u00E9 est de {2}.
core.persistencestore.toomanyobjforcard1=JDO76403 : la base de donn\u00E9es n''est pas coh\u00E9rente avec le mod\u00E8le persistant. La tentative d''extraction de l''objet d\u00E9fini par l''association de {1} de la classe {0} a fourni {2} \u00E9l\u00E9ments, mais 1 seul \u00E9l\u00E9ment peut \u00EAtre trait\u00E9 car la limite sup\u00E9rieure de la cardinalit\u00E9 pour l''association est de 1.
core.persistencestore.toomanyrows=JDO76405 : la tentative d''obtention \u00E0 partir de la base de donn\u00E9es de la valeur pour l''association {1} de la classe {0} a renvoy\u00E9 un nombre de lignes sup\u00E9rieur au nombre autoris\u00E9 par la cardinalit\u00E9 de cette association. Le nombre maximal de lignes autoris\u00E9 est de {2}.
core.store.concurrentaccess=JDO76406 : exception d''acc\u00E8s simultan\u00E9 : l''objet vers {0} a d\u00E9j\u00E0 \u00E9t\u00E9 mis \u00E0 jour ou supprim\u00E9 par une autre transaction.
sqlstore.sqlstoremanager.errorcloseresultset=JDO76407 : erreur lors de la fermeture de l''ensemble de r\u00E9sultats SQL. Exception : {0}
sqlstore.sqlstoremanager.errorclosestatement=JDO76408 : erreur lors de la fermeture de l''instruction SQL. Exception : {0}
sqlstore.sql.generator.selectqueryplan.plansnotjoined=JDO76409 : plans de requ\u00EAtes multiples non pris en charge pour RetrieveDesc.

#
# <NOI18N: SQLStoreManager>
#
sqlstore.sqlstoremanager.executeQuery.exit=<-- SQLStoreManager.executeQuery().
sqlstore.sqlstoremanager.executeQuery=--> SQLStoreManager.executeQuery().
sqlstore.sqlstoremanager.executeupdate.exit=<-- SQLStoreManager.executeUpdate(), lignes affect\u00E9es = {0}.
sqlstore.sqlstoremanager.executeupdate=--> SQLStoreManager.executeUpdate().
sqlstore.sqlstoremanager.executeupdatebatch.addbatch={0} ; ajouter le batch.
sqlstore.sqlstoremanager.executeupdatebatch.exit=<-- SQLStoreManager.executeUpdateBatch().
sqlstore.sqlstoremanager.executeupdatebatch.exit.flush=<-- SQLStoreManager.executeUpdateBatch(), lignes affect\u00E9es = {0}.
sqlstore.sqlstoremanager.executeupdatebatch.flushbatch={0} ; vider le batch.
sqlstore.sqlstoremanager.executeupdatebatch=--> SQLStoreManager.executeUpdateBatch().
sqlstore.sqlstoremanager.getpersistenceconfig=<--> SQLStoreManager.getPersistenceConfig(), classType = {0}.
sqlstore.sqlstoremanager.selectnoncorrelated.exit=<-- SQLStoreManager.selectNonCorrelated().
sqlstore.sqlstoremanager.selectnoncorrelated=--> SQLStoreManager.selectNonCorrelated().
sqlstore.sqlstoremanager.vendortype=<--> SQLStoreManager : type de fournisseur = {0}.


###############################################################################
# <Connection/Connectionpool/DBVendorType/TransactionImpl/OracleSpecialDBOperation>
# Message ID Range: JDO76500 - JDO76599
###############################################################################
#
# <Connection/Connection Pool> - database
#
connection.connectionmanager.badnew=JDO76500 : le nouvel \u00E9l\u00E9ment ''{0}'' doit \u00EAtre sup\u00E9rieur ou \u00E9gal \u00E0 l''\u00E9l\u00E9ment ''{1}'' actuel.
connection.connectionmanager.badvalue=JDO76501 : la valeur pour ''{0}'' n''est pas valide.
connection.connectionmanager.conntimeout=JDO76502 : fin du d\u00E9lai de connexion.
connection.connectionmanager.getconnection.mismatch=JDO76503 : la connexion mise en pool n'a pas le m\u00EAme contexte utilisateur.
connection.connectionmanager.isdown=JDO76504 : l'arr\u00EAt du gestionnaire de connexions est en cours.
connection.connectionmanager.maxpool=JDO76505 : le pool de connexions est \u00E0 son maximum.
connection.connectionmanager.msintervalvalue=JDO76506 : MsInterval doit \u00EAtre sup\u00E9rieur \u00E0 z\u00E9ro et inf\u00E9rieur ou \u00E9gal \u00E0 MsWait.
connection.connectionmanager.mswaitvalue=JDO76507 : MsWait doit \u00EAtre sup\u00E9rieur ou \u00E9gal \u00E0 z\u00E9ro.
connection.connectionmanager.nulldriver=JDO76508 : valeur NULL pour le nom du pilote.
connection.connectionmanager.nullurl=JDO76509 : valeur NULL pour l'URL.
connection.connectionmanager.poolsize=JDO76510 : 'maxPool' doit \u00EAtre sup\u00E9rieur ou \u00E9gal \u00E0 'minPool'.
connection.connectionmanager.threaditerupted=JDO76511 : thread interrompu.
connection.connectionmanager.zero=JDO76512 : ''{0}'' doit \u00EAtre sup\u00E9rieur ou \u00E9gal \u00E0 z\u00E9ro.
#
# <DBVendorType>
#
sqlstore.database.dbvendor.cantloadDefaultProperties=JDO76513\u00A0: impossible de charger les propri\u00E9t\u00E9s de la base de donn\u00E9es par d\u00E9faut.
sqlstore.database.dbvendor.init.default=JDO76514 : --> Impossible de charger la propri\u00E9t\u00E9 pour le type de fournisseur {0}. La valeur par d\u00E9faut va \u00EAtre utilis\u00E9e.
sqlstore.database.dbvendor.cantinstantiateclass=JDO76515 : \u00E9chec de l''instanciation de la classe {0}.
#
# <OracleSpecialDBOperation>
#
sqlstore.database.oracle.defineCol=JDO76516 : \u00E9chec de la d\u00E9finition d'une colonne pour l'instruction.
sqlstore.database.oracle.nooracleavailable=JDO76517 : \u00E9chec de l''obtention d''une instance oracle.jdbc.OraclePreparedStatement ou oracle.jdbc.driver.OraclePreparedStatement lors de l''initialisation de la fabrique de ressources Oracle ''{0}''. La fonction d''optimisation d''Oracle va \u00EAtre d\u00E9sactiv\u00E9e. Si des instances utilisant cette ressource exigent des valeurs de liaison pour les colonnes mapp\u00E9es \u00E0 la colonne ''Fixed Char'', les valeurs seront compl\u00E9t\u00E9es avec des espaces sur la longueur sp\u00E9cifi\u00E9e dans le fichier dbschema correspondant.
sqlstore.database.oracle.fixedcharpadded=JDO76518 : la valeur "{0}" est li\u00E9e \u00E0 une colonne CHAR. Une gestion particuli\u00E8re est requise pour Oracle. Etant donn\u00E9 que la classe OraclePreparedStatement n''a pas pu \u00EAtre extraite du pilote, la valeur est compl\u00E9t\u00E9e avec des espaces sur la longueur {1}, tel qu''indiqu\u00E9 dans le fichier dbschema captur\u00E9.
#
# <Misc.>
#
core.configuration.getvendortypefailed=JDO76519 : impossible d'identifier le type de fournisseur pour la banque de donn\u00E9es.
jdo.sqlpersistencemanagerfactory.errorgettingDatabaseInfo=JDO76520 : erreurs lors de l'obtention d'informations sur la base de donn\u00E9es. L'exception suivante s'est produite :

#
# <NOI18N: Connection>
#
sqlstore.connection.conncectiomgr.found=<--> ConnectionManager.getConnection : {0} trouv\u00E9.
sqlstore.connection.conncectiomgr.getnewconn=<--> ConnectionManager.getConnection : nouveau {0}.
sqlstore.connection.conncectiomgr.replacefreeconn=<--> ConnectionManager.replaceFreeConnection : {0} libre.
sqlstore.connectionimpl.clearxact.close=--- ConnectionImpl.clearXact : connexion ferm\u00E9e.
sqlstore.connectionimpl.clearxact.disassocxact=--- ConnectionImpl.clearXact : disassociateXact.
sqlstore.connectionimpl.clearxact=--- ConnectionImpl.clearXact :.
sqlstore.connectionimpl.close.connrelease=<--- ConnectionImpl.close : connexion lib\u00E9r\u00E9e.
sqlstore.connectionimpl.close.exit=<--- ConnectionImpl.close : connexion ferm\u00E9e.
sqlstore.connectionimpl.close.freepending=<--- ConnectionImpl.close : d\u00E9finir FreePending.
sqlstore.connectionimpl.close.putfreelist=<--- ConnectionImpl.close : plac\u00E9 dans freeList.
sqlstore.connectionimpl.close.replaced=<--- ConnectionImpl.close : connexion remplac\u00E9e.
sqlstore.connectionimpl.close=---> ConnectionImpl.close.
sqlstore.connectionimpl.close_arg=---> ConnectionImpl.close : {0}.
sqlstore.connectionimpl.commit=--- ConnectionImpl.commit : connexion ferm\u00E9e.
sqlstore.connectionimpl.finalize=--- ConnectionImpl.finalize : connexion ferm\u00E9e.
sqlstore.connectionimpl.internalcommit=--- ConnectionImpl.internalCommit :.
sqlstore.connectionimpl.pendingdisassocxact=--- ConnectionImpl.clearXact : disassociateXact en suspens.
sqlstore.connectionimpl.rollback.close=--- ConnectionImpl.rollback : connexion ferm\u00E9e.
sqlstore.connectionimpl.rollback=--- ConnectionImpl.rollback :.
#
# <NOI18N: DBVendorType>
#
sqlstore.database.dbvendor.castRequiredForNumericValues=<-> DBVendorType.isCastRequiredForNumericValues() : {0}.
sqlstore.database.dbvendor.getModFunctionName=<-> DBVendorType.getModFunctionName() : {0}.
sqlstore.database.dbvendor.getNullComparisonFunctionName=<-> DBVendorType.getNullComparisonFunctionName() : {0}.
sqlstore.database.dbvendor.getConcatCast=<-> DBVendorType.getConcatCast() : {0}.
sqlstore.database.dbvendor.getSpecialDBOperation=<-> DBVendorType.getSpecialDBOperation() : {0}.
sqlstore.database.dbvendor.getabs=<-> DBVendorType.getAbs() : {0}.
sqlstore.database.dbvendor.getcharlength=<-> DBVendorType.getCharLength() : {0}.
sqlstore.database.dbvendor.getforupdate=<-> DBVendorType.getForUpdate() : {0}.
sqlstore.database.dbvendor.getholdlock=<-> DBVendorType.getHoldlock() : {0}.
sqlstore.database.dbvendor.getisnotnull=<-> DBVendorType.getIsNotNull() : {0}.
sqlstore.database.dbvendor.getisnull=<-> DBVendorType.getIsNull() : {0}.
sqlstore.database.dbvendor.getleftjoin=<-> DBVendorType.getLeftJoin() : {0}.
sqlstore.database.dbvendor.getleftjoinpost=<-> DBVendorType.getLeftJoinPost() : {0}.
sqlstore.database.dbvendor.getleftlikeescape=<-> DBVendorType.getLeftLikeEscape() : {0}.
sqlstore.database.dbvendor.getnotequal=<-> DBVendorType.getNotEqual(): {0}.
sqlstore.database.dbvendor.getposition3args=<-> DBVendorType.getPositionThreeArrgs() : {0}.
sqlstore.database.dbvendor.getposition=<-> DBVendorType.getPosition() : {0}.
sqlstore.database.dbvendor.getpositionin=<-> DBVendorType.getPositionIn() : {0}.
sqlstore.database.dbvendor.getpositionsrchsrc=<-> DBVendorType.getPositionSearchSource() : {0}.
sqlstore.database.dbvendor.getquotecharstart=<-> DBVendorType.getQuoteCharStart() : {0}.
sqlstore.database.dbvendor.getrightjoinipre=<-> DBVendorType.getRightJoin() : {0}.
sqlstore.database.dbvendor.getrightlikeescape=<-> DBVendorType.getRightLikeEscape() : {0}.
sqlstore.database.dbvendor.getrtrim=<-> DBVendorType.getRtrim() : {0}.
sqlstore.database.dbvendor.getrtrimpost=<-> DBVendorType.getRtrimPost() : {0}.
sqlstore.database.dbvendor.getsqrt=<-> DBVendorType.getSqrt() : {0}.
sqlstore.database.dbvendor.getstringconcat=<-> DBVendorType.getStringConcat() : {0}.
sqlstore.database.dbvendor.getsubstring=<-> DBVendorType.getSubstring() : {0}.
sqlstore.database.dbvendor.getsubstringfor=<-> DBVendorType.getSubstringFor() : {0}.
sqlstore.database.dbvendor.getsubstringfrom=<-> DBVendorType.getSubstringFrom() : {0}.
sqlstore.database.dbvendor.gettablelistend=<-> DBVendorType.getTableListEnd() : {0}.
sqlstore.database.dbvendor.gettableliststart=<-> DBVendorType.getTableListStart() : {0}.
sqlstore.database.dbvendor.isAnsiTrim=<-> DBVendorType.isAnsiTrim() : {0}.
sqlstore.database.dbvendor.isInlineNumeric=<-> DBVendorType.isInlineNumeric() : {0}.
sqlstore.database.dbvendor.isNativeOuterJoin=<-> DBVendorType.isNativeOuterJoin() : {0}.
sqlstore.database.dbvendor.isParameterCast=<-> DBVendorType.isParameterCast() : {0}.
sqlstore.database.dbvendor.isdistinctupdatelocksupported=<-> DBVendorType.isDistinctSupportedWithUpdateLock() : {0}.
sqlstore.database.dbvendor.islockcolumnlistsupported=<-> DBVendorType.isLockColumnListSupported() : {0}.
sqlstore.database.dbvendor.isupdatelocksupported=<-> DBVendorType.isUpdateLockSupported() : {0}.
sqlstore.database.dbvendor.mapemptystrtonull=<-> DBVendorType.mapEmptyStringToNull() : {0}.
sqlstore.database.dbvendor.overrideproperties.with=<-> DBVendorType.overrideProperties() : {0} avec : {1}.
sqlstore.database.dbvendor.overrideproperties=<-> DBVendorType.overrideProperties() - NONE.
sqlstore.database.dbvendor.supportslikeescape=<-> DBVendorType.supportsLikeEscape() : {0}.
sqlstore.database.dbvendor.vendorname=<-> DBVendorType(), vendorName : [{0}] vendorType : {1}.
#
# <NOI18N: TransactionImpl>
#
sqlstore.transactionimpl.call.info={0} Tran[ {1} ].{2}: {3} for  {4}.
sqlstore.transactionimpl.call={0} Tran[ {1} ].{2}:status = {3}, txType: {4} for  {5}.
sqlstore.transactionimpl.closeconnection=--- TransactionImpl.closeConnection() {0} for {1}.
sqlstore.transactionimpl.general={0}.
sqlstore.transactionimpl.getconnection=--- TransactionImpl.getConnection(): {0} TX optimistic: {1} referenceCount = {2} for {3}.
sqlstore.transactionimpl.releaseconnection=--- TransactionImpl.releaseConnection(): TX optimistic: {0} Inside Commit: {1} referenceCount: {2} for {3}.
sqlstore.transactionimpl.rollbackconnection=--- TransactionImpl.rollbackConnection(): {0} for {1}.
sqlstore.transactionimpl.status={0} Tran[ {1} ].setStatus: {2} => {3} for {4}.


###############################################################################
# All the source files under subdir ejb.
# Message ID Range: JDO76600 - JDO76699
###############################################################################
#
#EJBHelper messages
#
# {0} - method name
ejb.ejbhelper.nonmanaged=JDO76600 : vous ne pouvez pas appeler la m\u00E9thode {0} dans un environnement qui n''est pas g\u00E9r\u00E9.

#
# Common messages between SunContainerHelper and DeploymentHelper
# so they have a neutral key, that still starts with "ejb".
#
# {0} - jndi name.
ejb.jndi.lookupfailed=JDO76604 : \u00E9chec de la recherche JNDI d''une ressource CMP ''{0}''.
JDO76604.diag.cause.1=La ressource CMP portant ce nom JNDI n'est pas inscrite aupr\u00E8s de cette instance.
JDO76604.diag.cause.2=Le nom JNDI de la ressource CMP est mal orthographi\u00E9.
JDO76604.diag.check.1=V\u00E9rifiez le nom JNDI de la ressource \u00E0 utiliser.
JDO76604.diag.check.2=V\u00E9rifiez le nom JNDI de la ressource CMP sp\u00E9cifi\u00E9e dans le module.

# {0} - jndi name.
# {1} - returned class name.
ejb.jndi.unexpectedinstance=JDO76605 : la recherche JNDI d''une ressource CMP ''{0}'' a renvoy\u00E9 une instance de type inattendu : {1}.
JDO76605.diag.cause.1=La ressource CMP portant ce nom JNDI ne fait pas r\u00E9f\u00E9rence \u00E0 la ressource jdbc-resource ou persistence-manager-factory-resource.
JDO76605.diag.cause.2=Le nom JNDI de la ressource CMP est mal orthographi\u00E9.
JDO76605.diag.check.1=V\u00E9rifiez le nom JNDI de la ressource \u00E0 utiliser.
JDO76605.diag.check.2=V\u00E9rifiez le nom JNDI de la ressource CMP sp\u00E9cifi\u00E9e dans le module.

#
# DeploymentHelper messages - ejb
#
#
#<NOI18N: DeploymentHelper>
#
ejb.DeploymentHelper.getconnection=Obtention de la connexion pour le nom JNDI ''{0}''.

# The messages JDO76606 through JDO76615 that were originally here 
# have been moved to 
# cmp/support/ejb/src/com/sun/jdo/spi/persistence/support/ejb/ejbc/Bundle.properties
# As part of INF#
# So do not use these messages. 


#
#CMPHelper messages
#
ejb.cmphelper.nonmanaged=JDO76613 : acc\u00E8s non valide \u00E0 CMPHelper. Cette classe est utilis\u00E9e pour la prise en charge CMP uniquement et ne doit pas \u00EAtre appel\u00E9e en dehors du serveur d'applications.

#
#SunTransactionHelper messages
#

# {0} class name
ejb.SunTransactionHelper.wrongdatasourcetype=JDO76616 : dataSource ne correspond pas au type attendu. Attendu : com.sun.appserv.jdbc.DataSource, obtenu : {0}.


###############################################################################
# <Generic messages. Add new messages to this section only if none of the above categories can be used.>
###############################################################################
#
# <NOI18N: generic>
#
vendor=Sun Microsystems
# majorVersion (minorVersion) buildDate
fullVersion={0} ({1}) {2}
#
# <NOI18N: This messages are used for JDOFatalInternalException from multiple places. No need to I18N>
#
core.generic.unknownfield=Le champ {0} n''est pas un membre de la classe {1}.
core.generic.unknownexception=Exception inconnue g\u00E9n\u00E9r\u00E9e.
core.generic.nullparam=Le param\u00E8tre {0} est NULL.
core.generic.notinstanceof=L''objet de classe {0} n''est pas une instance de {1}.


###############################################################################
# <These messages are used from multiple places in code.It is absolutely necessary to cleanup code
# to use different messages >
###############################################################################
core.configuration.cantloadclass=Echec du chargement de la classe {0}.
sqlstore.exception.log=Exception.
jdo.lifecycle.deleted.accessField=Impossible d'acc\u00E9der au champ d'une instance supprim\u00E9e.
