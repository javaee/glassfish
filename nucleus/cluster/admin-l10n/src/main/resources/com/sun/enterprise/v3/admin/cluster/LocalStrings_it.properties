#
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
#
# Copyright (c) 2010-2017 Oracle and/or its affiliates. All rights reserved.
#
# The contents of this file are subject to the terms of either the GNU
# General Public License Version 2 only ("GPL") or the Common Development
# and Distribution License("CDDL") (collectively, the "License").  You
# may not use this file except in compliance with the License.  You can
# obtain a copy of the License at
# https://oss.oracle.com/licenses/CDDL+GPL-1.1
# or LICENSE.txt.  See the License for the specific
# language governing permissions and limitations under the License.
#
# When distributing the software, include this License Header Notice in each
# file and include the License file at LICENSE.txt.
#
# GPL Classpath Exception:
# Oracle designates this particular file as subject to the "Classpath"
# exception as provided by Oracle in the GPL Version 2 section of the License
# file that accompanied this code.
#
# Modifications:
# If applicable, add the following below the License Header, with the fields
# enclosed by brackets [] replaced by your own identifying information:
# "Portions Copyright [year] [name of copyright owner]"
#
# Contributor(s):
# If you wish your version of this file to be governed by only the CDDL or
# only the GPL Version 2, indicate your decision by adding "[Contributor]
# elects to include this software in this distribution under the [CDDL or GPL
# Version 2] license."  If you don't indicate a single choice of license, a
# recipient has the option to distribute your version of this file under
# either the CDDL, the GPL Version 2 or to extend the choice of license to
# its licensees as provided above.  However, if you add GPL Version 2 code
# and therefore, elected the GPL Version 2 license, then the option applies
# only if the new code is made subject to such option by the copyright
# holder.
#

#####restart-instance
restart.instance.notInstance=-_restart-instance funziona solamente sulle istanze. Questo \u00E8 {0}
#Below {0} is the runtime-type.  currently DAS, INSTANCE, EMBEDDED, NODEAGENT or ALL
restart.instance.notDas=restart-instance funziona solamente con DAS. Questo \u00E8 {0}
restart.notRestartable={0} indica che non \u00E8 riavviabile. \nIn genere, questo significa che il password file usato originariamente per avviare {0} \u00E8 stato eliminato o non \u00E8 leggibile in questo momento.\nArrestare e quindi avviare {0} o correggere il password file.
restart.instance.success={0} \u00E8 stata riavviata.
restart.instance.racError=Errore durante il tentativo di riavviare l''istanza denominata {0}: {1}
restart.instance.timeout=Timeout durante l''attesa del riavvio di {0}
restart.instance.nopid=Impossibile ottenere l''ID processo per {0}
restart.instance.startSucceeded=L''istanza non era in esecuzione. L''avvio normale \u00E8 riuscito.\nMessaggio da start-instance: {0}
restart.instance.startFailed=L''istanza non \u00E8 in esecuzione. Un avvio \u00E8 stato tentato ma non \u00E8 riuscito. \nProvare ad avviare l''istanza con start-local-instance.\nMessaggio da start-instance: {0}
## StopInstanceCommand
stop.instance.command=Arresta un'istanza in esecuzione
stop.instance.init=Chiusura dell''istanza {0} avviata
stop.instance.notDas=stop-instance funziona solamente con DAS. Questo \u00E8 {0}
stop.instance.notInstance=_stop-instance funziona solamente sulle istanze. Questo \u00E8 {0}
stop.instance.noInstanceName=Specificare un nome istanza.
stop.instance.noSuchInstance=Nessuna istanza denominata {0} in questo dominio.
stop.instance.noPort=Impossibile trovare la porta di amministrazione per l''istanza denominata {0}.
stop.instance.noHost=Impossibile trovare il nome dell''host per l''istanza denominata {0}.
stop.instance.racError=Errore durante il tentativo di arrestare l''istanza denominata {0}: {1}
stop.instance.success=L''istanza {0} \u00E8 arrestata.
stop.instance.timeout=Timeout durante l''attesa dell''arresto di {0}.
stop.instance.timeout.completely=Timeout durante l''attesa dell''arresto completo di {0}.
## StartInstanceCommand
start.instance.success=L''istanza {0} \u00E8 stata avviata sull''host {1}
start.instance.already.running=L''istanza {0} \u00E8 gi\u00E0 in esecuzione.
start.instance.command=Avvia un'istanza
start.instance.init=Avvio istanza iniziato
start.instance.notAnInstanceOrDas=start-instance funziona solamente con istanze o DAS, questo \u00E8 {0}
start.instance.noInstanceName=Specificare un nome istanza quando si chiama start-instance su DAS.
start.instance.noSuchInstance=Nessuna istanza denominata {0} in questo dominio.
start.instance.noSuchNodeRef=Nessun nodo denominato {0} in questo dominio.
# 0=instance, 1=node, 2=host
start.instance.failed=Impossibile avviare l''istanza {0} sul nodo {1} ({2}).
start.instance.timeout=Timeout durante l''attesa dell''avvio di {0}.
stop.local.instance.kill=Arresto dell''istanza {0} sul nodo {1} utilizzando {2} non riuscito
## ListInstancesCommand
list.instances.command=Visualizza lo stato delle istanze server
list.instances.onlyRunsOnDas=Questa \u00E8 un'istanza server GlassFish e list-instances pu\u00F2 essere eseguito solamente su DAS.
## SynchronizeFiles
sync.unknown.instance=Istanza server sconosciuta: {0}
sync.exception.reading=SynchronizeFiles: eccezione durante la lettura della richiesta
sync.exception.processing=Synchronizefiles: eccezione durante l'elaborazione della richiesta
sync.bad_output_file=Impossibile scrivere nel file di output {0}.
## ExportSyncBundle
sync.bad_temp_file=Impossibile creare un file temporaneo nell''area dei file temporanei del sistema: {0}
sync.unknown.instanceOrCluster=Server standalone o cluster sconosciuto: {0}
sync.empty_cluster=Impossibile generare il bundle di sincronizzazione. Il cluster {0} non ha istanze.
export.sync.bundle.success=Bundle di sincronizzazione: {0}
export.sync.bundle.fail=Impossibile esportare il bundle di sincronizzazione: {0}
export.sync.bundle.retrieveFailed=Impossibile recuperare il bundle di sincronizzazione: {0}
export.sync.bundle.exportFailed=Impossibile esportare il contenuto sincronizzato nel file {0}: {1}.
export.sync.bundle.closeStreamFailed=Impossibile chiudere il flusso nel file {0}: {1}
export.sync.bundle.createDirFailed=Impossibile creare la directory {0}.
## ServerSynchronizer
serversync.unknown.dir=Directory sconosciuta: {0}
serversync.exception.processing=ServerSynchronizer: eccezione durante l'elaborazione della richiesta
## GlassFishClusterExecutor
glassfish.clusterexecutor.notargets=Non sono state trovate istanze idonee per la destinazione {0}. Comando eseguito solamente su DAS.
glassfish.clusterexecutor.notargetspecified=Nella riga di comando non \u00E8 stata specificata alcuna destinazione. L'ulteriore esecuzione dell'interfaccia CLI verr\u00E0 interrotta.
glassfish.clusterexecutor.supplementalcmdfailed=Comando supplementare {0} non riuscito
glassfish.clusterexecutor.dynrecfgdisabled=AVVERTENZA: il comando non \u00E8 stato replicato per tutte le istanze cluster poich\u00E9 il flag dynamic-reconfiguration-enabled \u00E8 impostato su false per il/i cluster {0}

noNode=nodo nullo
noUpdate.nodeInUse=Impossibile aggiornare il nodo {0}. Viene utilizzato da un''istanza server e pertanto \u00E8 impossibile modificare l''attributo {1}.
notConfigNode=Il nodo {0} non \u00E8 un nodo di configurazione.
notSshNode=Il nodo {0} non \u00E8 un nodo SSH.
missingNodeRef=All''istanza {0} non \u00E8 associato alcun nodo.
missingNode=Nodo {0} inesistente.
attribute.mismatch=Mancata corrispondenza di attributi per il nodo ''{0}'': il valore per l''attributo ''{1}'' del comando ({2}) non corrisponde al valore nella configurazione DAS ({3})
attribute.null=Attributo nullo per l''attributo {1} sul nodo {0}: il valore del comando \u00E8 {2}, il valore del nodo \u00E8 {3}
top.instance.notRunning=L''istanza {0} non \u00E8 in esecuzione.
invalid.installdir=Il valore installdir {0} non \u00E8 un''installazione GlassFish valida.

## CreateInstanceCommand
generic.config=Nome della configurazione esistente da utilizzare in questo cluster

create.instance=Crea una nuova istanza server GlassFish
create.instance.cluster=Il nome del cluster al quale deve essere associata questa nuova istanza
create.instance.success=L''istanza {0} \u00E8 stata creata sull''host {1}
create.instance.missing.info=Il nodo {0} non ha l''attributo {1} impostato e pertanto {2} non pu\u00F2 essere utilizzato con questo nodo. Aggiungere l''attributo {1} tramite il comando {3} oppure creare l''istanza eseguendo {4} direttamente sul relativo host.
create.instance.config=L''istanza {0} \u00E8 stata registrata con DAS. Per completare la creazione dell''istanza, eseguire il seguente comando sull''host dell''istanza: \n {1}
create.instance.usagetext=create-instance --node <node> \n\t[--config <config> | --cluster <cluster>] \n\t[--lbenabled[=<lbenabled>]] \n\t[--checkports[=<checkports(default:true)>]] [--portbase <portbase>] \n\t[--systemproperties <systemproperties>] \n\t[-?|--help[=<help(default:false)>]] instance_name
creatingInstance=Creazione dell''istanza {0} in {1}
mustRunLocal=Impossibile accedere all''host {0} per il nodo {1}. Per completare la creazione dell''istanza, eseguire il seguente comando sull''host {0}: {2}

noSuchNode=Nessun nodo denominato {0} in questo dominio.
notConfigNodeType=Il nodo {0} non \u00E8 del tipo CONFIG
notRemoteNodeType=Il nodo {0} non \u00E8 di un tipo remoto (SSH o DCOM).
lbenabledNotForStandaloneInstance=L'opzione lbenabled non \u00E8 supportata per le istanze standalone.

notAllowed=Questo comando pu\u00F2 essere eseguito solamente su DAS.
## StartClusterCommand
start.cluster.command=Avvia un cluster
start.cluster=Avvio del cluster {0}
stop.cluster.command=Arresta un cluster
stop.cluster=Arresto del cluster {0}
cluster.command.notDas=Questa \u00E8 un''istanza server GlassFish e {0} pu\u00F2 essere eseguito solamente su DAS.
cluster.command.instancesSucceeded=Comando {0} riuscito per: {1}
cluster.command.instancesFailed=Comando {0} non riuscito per: {1}
cluster.command.instancesTimedOut=Timeout durante l''attesa del completamento del comando {0} per: {1}
cluster.command.unknownCluster=Nessun cluster denominato {0} in questo dominio.
cluster.command.noInstances=Il cluster {0} non contiene istanze.
cluster.command.interrupted=Il comando per il cluster {0} \u00E8 stato interrotto dopo la ricezione di risposte da {1} delle {2} istanze per il comando {3}.
cluster.command.executing=Esecuzione di {0} su {1} istanze.
create.instance.local.boot.failed=La creazione dell''istanza {0} nella configurazione DAS \u00E8 riuscita, ma non \u00E8 stato possibile recuperare i file di configurazione durante il bootstrap.
create.instance.remote.boot.failed=La creazione dell''istanza {0} nella configurazione DAS \u00E8 riuscita, ma non \u00E8 stato possibile installare i file di configurazione per l''istanza sul nodo {3} durante il bootstrap.\n\nInformazioni sulla configurazione SSH \n{1}\n Informazioni aggiuntive sull''errore: {2}.

deleting.instance=Eliminazione dell''istanza {0} su {1}
instance.shutdown=Arrestare l''istanza {0} per poterla eliminare.
delete.instance.success=L''istanza {0} \u00E8 stata eliminata dall''host {1}
delete.instance.failed=Eliminazione dell''istanza {0} da {1} non riuscita
#delete.instance.config.failed: {0} server instance name, {1} is hostname
delete.instance.config.failed=La rimozione dei file per l''istanza {0} da {1} \u00E8 riuscita, ma non \u00E8 stato possibile eliminare l''istanza dalla configurazione DAS.
delete.instance.filesystem.failed=La rimozione dell''istanza {0} dalla configurazione DAS \u00E8 riuscita, ma non \u00E8 stato possibile rimuovere i file di istanza dal nodo {1} ({2}).

restart.instance.command=riavvia un'istanza server in esecuzione
list.instances.badTarget=La destinazione {0} non \u00E8 un''istanza, un cluster, un dominio, un nodo o una configurazione.
list.instances.targetWithStandaloneOnly=Le opzioni target e standaloneonly si escludono a vicenda. Sceglierne solamente una.
list.instances.longAndNoStatus=Le opzioni long e nostatus si escludono a vicenda. Sceglierne solamente una.
list.instances.serverTarget=La destinazione \u00E8 stata specificata come DAS. L'operazione non \u00E8 valida perch\u00E9 DAS non \u00E8 un'istanza server.

Config.badConfigNames=Specificare una configurazione di origine e di destinazione.
Config.noSuchConfig=Configurazione {0} inesistente.
#Config.copyConfigError {0} is the message from the Exception that was thrown
Config.copyConfigError=Errore durante la copia della configurazione causato da {0}.
Config.configExists=Configurazione {0} gi\u00E0 esistente.
Config.inUseConfig=La configurazione {0} \u00E8 in uso e non vi deve essere fatto riferimento da istanze server o cluster
Config.defaultConfig=Impossibile eliminare il modello di configurazione predefinito denominato default-config.
Config.deleteConfigFailed=Impossibile rimuovere la configurazione {0}

create.instance.filesystem.failed=La creazione dell''istanza {0} nella configurazione DAS \u00E8 riuscita, ma non \u00E8 stato possibile creare i file di istanza sul nodo {1} ({2}).

# Messages for connecting to SSH nodes
# 0=node name, 1=hostname
node.not.ssh=Questo comando richiede la connessione al nodo {0} ({1}) tramite SSH per completare l''operazione, ma il nodo {0} non \u00E8 configurato per l''uso di SSH. \u00C8 possibile utilizzare update-node-ssh per configurare il nodo {0} all''uso di SSH.
# 0=node name, 1=hostname, 2=more info
node.ssh.bad.connect=Questo comando richiede la connessione all''host {1} tramite SSH per completare l''operazione, ma non \u00E8 riuscito a connettersi:\n\n {2}\n\nVerificare di disporre della corretta configurazione SSH sul sistema, con gli attributi appropriati impostati sul nodo {0}. \u00C8 possibile utilizzare update-node-ssh per modificare gli attributi. Per ulteriori informazioni, consultare il file di log di DAS.
# 0=hostname, 1=installdir, 2=more info
node.remote.tocomplete=Per completare l''operazione, eseguire il seguente comando in locale sull''host {0} dalla posizione di installazione GlassFish {1}:\n\n {2}
# A command return a non-zero status
# 0=node, 1=node-host, 2=output from failed command, 3=command
node.command.failed=Comando ''{3}'' non riuscito sul nodo {0} ({1}): {2}
node.command.failed.short=Comando non riuscito sul nodo {0} ({1}): {2}
node.command.failed.local.exception=Esecuzione non riuscita del comando locale: {0}
node.command.failed.local.details=Esecuzione non riuscita del comando locale ''{1}'': {0}
# Failed to execute a command via SSH
# 0=node, 1=node-host, 2=command, 3=exception info, 4=SSH settings
node.command.failed.ssh.details=Esecuzione non riuscita di ''{2}'' sul nodo {0} ({1}): {3}. Impostazioni SSH: {4}

create.node.ssh.continue.force=Creazione del nodo ancora in corso a causa dell'uso di --force.
create.node.ssh.or.dcom.not.created=Nodo {0} non creato. Per forzare la creazione del nodo con questi parametri, rieseguire il comando utilizzando l''opzione --force.
create.node.ssh.install.success=Installazione di GlassFish su {0} riuscita.
delete.node.ssh.uninstall.failed=Eliminazione del nodo {0} riuscita, ma non \u00E8 stato possibile disinstallare GlassFish su {1}. Eseguire uninstall-node manualmente.
delete.node.ssh.uninstall.success=Disinstallazione di GlassFish su {0} riuscita.
create.node.ssh.no.installdir=Il nodo non ha una directory di installazione.
update.node.ssh.continue.force=Aggiornamento del nodo ancora in corso a causa dell'uso di --force.
update.node.ssh.not.updated=Nodo non aggiornato. Per forzare un aggiornamento del nodo con questi parametri, rieseguire il comando utilizzando l'opzione --force.
update.node.config.missing.attribute=Per aggiornare il nodo {0}, \u00E8 necessario l''attributo {1}.
update.node.config.defaultnode=Impossibile aggiornare il nodo {0}. \u00C8 il nodo localhost built-in.
node.ssh.invalid.params=Avvertenza: alcuni parametri sembrano essere non validi.
ssh.bad.connect=Impossibile connettersi all''host {0} utilizzando {1}.
ssh.invalid.port=Numero di porta {0} non valido.
key.path.not.absolute=Il percorso del file di chiave {0} deve essere assoluto.
key.path.not.found=Impossibile trovare il file di chiave {0}. Il percorso del file di chiave deve essere raggiungibile da DAS.
key.path.not.readable=Il file di chiave {0} non \u00E8 leggibile dall''utente DAS {1}.
no.such.password.alias=Impossibile trovare l''alias password {0} nel dominio.
ping.node.failure=Convalida della connessione {2} al nodo {0} ({1}) non riuscita
ping.node.success=Connessione {2} al nodo {0} ({1}) riuscita
#ping.glassfish.version {0} is the installation directory path of the node.
#ping.glassfish.version {1} is the GlassFish version found on the node
ping.glassfish.version=Versione GlassFish trovata in {0}:\n{1}
unknown.host=Host sconosciuto {0}
nodehost.required=Impostare l'attributo dell'host del nodo.
#failed.to.run {0} is the actual command that was run, {1} is the name of the node.
failed.to.run=Esecuzione di ''{0}'' su {1} non riuscita

failed.to.update.node=Aggiornamento del nodo {0} non riuscito.

setup.ssh.null.sshpass=La password SSH non pu\u00F2 essere nulla.
setup.ssh.unalias.error=Impossibile ottenere la password SSH dal keystore del dominio per l''alias password {0} specificato.
setup.ssh.no.keyfile=Utilizzare l'opzione --generatekey per generare una chiave nuova poich\u00E9 non \u00E8 stato trovato alcun file di chiave.
setup.ssh.invalid.path=Il percorso del file di chiave {0} deve essere assoluto.
setup.ssh.already.configured=L''autenticazione SSH con chiave pubblica \u00E8 gi\u00E0 configurata per {0}@{1}
setup.ssh.failed=Configurazione non riuscita della chiave SSH: {0}
setup.ssh.conn.failed=Verifica della connessione non riuscita.
setup.ssh.null.keypassphrase=Impossibile ottenere la passphrase della chiave SSH dal keystore del dominio.
## GetHealthCommand
get.health.called=get-health chiamato per il cluster "{0}"
get.health.cluster.name=Nome del cluster per cui si richiedono le informazioni sullo stato.
get.health.command=Ottieni lo stato corrente delle istanze di un cluster.
get.health.no.instances=Impossibile trovare istanze per il cluster {0}.
get.health.noCluster=Cluster {0} inesistente.
get.health.noGMS=Il servizio GMS (Group Management Service) non \u00E8 in esecuzione per il cluster {0}. Impossibile ottenere lo stato delle istanze se il servizio GMS non \u00E8 in esecuzione.
get.health.noHistoryError=Errore imprevisto: impossibile trovare la cronologia dello stato GMS.
get.health.onlyRunsOnDas=Questa \u00E8 un'istanza server GlassFish e get-health pu\u00F2 essere eseguito solamente su DAS.

#get.health.instance.state.since -->  domain1 running since January 1, 2011
get.health.instance.state.since={0} {1} da {2}

secure.admin.boot.errCreDir=Impossibile creare directory per {0}. Non sono disponibili ulteriori informazioni.
secure.admin.boot.errSetLastMod=Impossibile impostare la data lastModified per {0}. Non sono disponibili ulteriori informazioni.
bad.dcom.ping=Errore durante la connessione remota con DCOM: {0}
dcom.no.remote.install=Impossibile trovare un''installazione GlassFish remota sull''host: {0} in {1}
dcom.no.connection=Impossibile connettersi tramite DCOM all''host remoto: {0}
internal.error=Errore interno: {0}
no.mkdir=Impossibile creare la directory sull''host remoto: {0}
dcom.connect.ok=Connessione a {0} tramite DCOM riuscita. Inoltre, \n\\l''esecuzione del comando version sull''installazione GlassFish remota \u00E8 riuscita.
dcom.no.remote.access=Impossibile accedere ai file {0} sull''host {1} tramite DCOM.
dcom.no.remote.file=Il file remoto {0} non esiste su {1}
dcom.no.remote.file.access=Impossibile accedere al file system remoto. Assicurarsi che UAC sia attivo.
dcom.access.ok=L''accesso a {0} su {1} tramite DCOM \u00E8 riuscito.
dcom.no.write=Impossibile scrivere {0} in {1} su {2} tramite DCOM.
dcom.write.ok=La scrittura di {0} in {1} su {2} tramite DCOM \u00E8 riuscita.
dcom.run.ok=L''esecuzione dello script di test su {0} tramite DCOM \u00E8 riuscita.\nLo script ha eseguito solo il comando DIR. Di seguito le prime righe dell''output del comando DIR sul computer remoto:\n\\{1}
dcom.no.run=Impossibile eseguire lo script di test su {0} tramite DCOM.
validate.dcom.getbyname=\nNome host risolto in: {0}
validate.dcom.connect=La connessione a {0} sulla porta {1} dell''host {2} \u00E8 riuscita.
validate.dcom.no.connect=Impossibile connettersi a {0} sulla porta {1} dell''host {2}.\nQuesto problema \u00E8 in genere causato da un firewall che impedisce l''accesso alla porta o dall''arresto del servizio server.
dcom.no.wmi=Impossibile connettersi a WMI (Windows Management Interface) su {0}.
dcom.wmi.ok=L''accesso a WMI (Windows Management Interface) su {0} \u00E8 riuscito. Ci sono {1} processi in esecuzione su {0}.
dcom.wmi.procinfolegend=Di seguito sono elencate le righe di comando per tutti i processi remoti che ne dispongono: \n
dcom.nopassword=Password di Windows mancante. Se si sta usando asadmin, specificare la password del sistema Windows remoto in un file, come segue:\nAS_ADMIN_WINDOWSPASSWORD=password-di-Windows\nSpecificare il percorso del password file ad asadmin utilizzando l'opzione --passwordfile (o -W).
dcom.no.installdir=La configurazione del nodo non \u00E8 valida. Il valore per installdir non \u00E8 presente. Provare a eseguire update-node-dcom e specificare la directory di installazione per GlassFish.
dcom.no.jdk=Impossibile trovare javac nel percorso su {0]. JDK deve essere configurato nel percorso.
dcom.yes.jdk=\u00C8 stato verificato che JDK \u00E8 installato e disponibile nel percorso su {0}. Il comando javac -version ha restituito l''output seguente: {1}
dcom.no.local=\u00C8 stato verificato che l''host {0} non \u00E8 il computer locale, come richiesto.
dcom.yes.local=L''host {0} \u00E8 il computer locale. DCOM pu\u00F2 essere usato solo su sistemi distribuiti.
