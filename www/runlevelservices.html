<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">










<html>
  <head>
    <title></title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      </head>
  <body class="composite">
    <!-- TODO: move this into JavaScript to patch the skin
      <div class="xright">  </div>
    -->
    <div id="bodyColumn">
      <div id="contentBox">
        <div class="section"><h2>Introduction<a name="Introduction"></a></h2><p>The RunLevelService was designed to offer life cycle controller mechanisms to a system. Life cycle involves the starting or stopping of a system in phases, known as run levels.</p><p>This is a departure from the traditional, ternary style of system life cycle which was represented by the state machine (NotStarted_or_Shutdown <i>--</i> Starting_or_Stopping <i>--</i> Running). The issue with the traditional approach is that it doesn't offer the proper granularity to target more nuanced features. For example, consider an application server that wants to startup to a level where it can managed by a systems administrator but before it is made available for general public use. By adding an &quot;admin run level&quot; the state machine for the application server now becomes (NotStarted_or_Shutdown <i>--</i> Starting_or_Stopping <i>--</i> <b>Admin</b> <i>--</i> Running).</p><p>The RunLevelService was also designed to support sub-systems within the global system, where the same life cycle controllers can be used, but having a different set of run levels that are meaningful to that sub-system.</p></div><div class="section"><h2>Overview<a name="Overview"></a></h2><p>The HK2 component system uses <a href="./hk2-api/apidocs/org/jvnet/hk2/annotations/RunLevel.html">RunLevel</a> to form higher levels of component life cycle. HK2 normally employs a &#x201c;lazy instantiation&#x201d; model for component creation. However, there are situations where the developer may want the instantiation to occur either immediately upon HK2 initialization or otherwise on some more regimented schedule. This can be accomplished using the RunLevel annotation.</p><div class="section"><h3>RunLevel's<a name="RunLevels"></a></h3><p>The <a href="./hk2-api/apidocs/org/jvnet/hk2/annotations/RunLevel.html">RunLevel</a> is a declarative form of annotation that you place on your Service class as shown in this example.</p><div class="source"><pre>@RunLevel(1)
@Service
public MyService implements MyContract {
...
}</pre></div><p>In this example, MyService was declared to be in run level &quot;1&quot; in the default, or global, run level scoping. This is called the run level value (in OSGi this is similar to the start level). The run level value must be an integer value. Run Level Scoping will be explained later.</p></div><div class="section"><h3>RunLevelService<a name="RunLevelService"></a></h3><p>The <a href="./auto-depends/apidocs/org/jvnet/hk2/component/RunLevelService.html">RunLevelService</a> is the controller responsible for (automatically) instantiating services annotated with the RunLevel annotation using the proceedTo() method on the RunLevelService interface.</p><div class="source"><pre>...
@Inject
RunLevelService rls;

public void start() {
  rls.proceedTo(1);
}
...</pre></div><p>It is also possible to interrogate the current and planned run levels (if the RunLevelService is currently operating) using the getState() method of the interface.</p></div><div class="section"><h3>Runtime Start Order<a name="Runtime_Start_Order"></a></h3><p>When two services are found to be in the same RunLevel they will be instatiated during the RunLevelService's proceedTo() operation provided that the run level value on the service is less than or equal to the argument passed to proceedTo(). The RunLevel service operates one run level value at a time.</p><div class="source"><pre>@RunLevel(1)
@Service
public MyService1 implements MyContract {
}

@RunLevel(1)
@Service
public MyService2 implements MyContract {
}

@RunLevel(2)
@Service
public MyService3 implements MyContract {
}

@RunLevel(2)
@Service
public MyService4 implements MyContract {
  @Inject
  MyService3 myService3;
}</pre></div><p>In this example, assuming we start from run level vlaue 0, a call to rls.proceedTo(2) will first instantiate (MyService1 | MyService2). While both services will eventually be instantiated, it is non-deterministic which of the two will actually come first (more on this later).</p><p>After all services annotated with the value of 1 in the default/global run level scope is located and instantiated from the HK2 service registry the system will proceed to run level value 2. This case is different in that the start order is deterministic - at least with respect to MyService3 and MyService4. MyService3 must be started before MyService4 because MyService4 depends upon (i.e., injects) MyService3.</p></div><div class="section"><h3>Runtime Stop Order<a name="Runtime_Stop_Order"></a></h3><p>The <a href="./auto-depends/apidocs/org/jvnet/hk2/component/RunLevelService.html">RunLevelService</a> can also be used to shutdown / release services that were previously instantiated. Continuing from the previous example, a call to proceedTo(0) will release MyService1 - MyService4. Note that shutdown will occur in the reverse order from the instantiation order. So the shutdown order will therefore be MyService4, MyService3, (MyService1 | MyService2).</p></div><div class="section"><h3>The &quot;Kernel&quot; RunLevel<a name="The_Kernel_RunLevel"></a></h3><p>The kernel run level has the value -1. It is considered special in that Services annotated with it will be instantiated immediately upon HK2 startup.</p></div><div class="section"><h3>Meta Annotations<a name="Meta_Annotations"></a></h3><p>As a convenience, you can create a meta annotation (i.e., stereotype) to use a more meaningful name/type to describe your RunLevel. HK2 comes with one such meta-annotation called @Immediate having run level value -1 as described above.</p><div class="source"><pre>@Retention(RUNTIME)
@Target(TYPE)
@Inherited
@RunLevel(RunLevel.KERNEL_RUNLEVEL)
public @interface Immediate {}</pre></div></div><div class="section"><h3>RunLevel Scope<a name="RunLevel_Scope"></a></h3><p>The RunLevel Scope, not to be confused with component <a href="./hk2-api/apidocs/org/glassfish/hk2/Scope.html">Scope</a>, permits namespace groupings of services to occur. When not declared on the RunLevel annotation, the default, or global, run level scope is implied. A class type is used to represent the run level scope and will default to <a href="./hk2-api/apidocs/org/glassfish/hk2/RunLevelDefaultScope.html">RunLevelDefaultScope</a> unless otherwise specified.</p><p>RunLevel scoping is useful for modeling life cycle for sub-systems which span more than a single service (e.g., &quot;the ejb container&quot;, &quot;the logging sub system&quot;, etc.).</p><p>See <a href="#Extensions">Extensions</a> for more information</p></div></div><div class="section"><h2>The Default RunLevelService<a name="The_Default_RunLevelService"></a></h2><p>HK2 comes configured with a default RunLevelService responsible for the services that are using the default, or global, RunLevel scope. The default RunLevel Service delegates part of its work to other services it attempts to find from the HK2 service registry. These services include the <a href="./auto-depends/apidocs/org/jvnet/hk2/component/InhabitantSorter.html">InhabitantSorter</a> and the <a href="./auto-depends/apidocs/org/jvnet/hk2/component/InhabitantActivator.html">InhabitantActivator</a>.</p><p>In addition to delegating work to the sorter and activator, the default RunLevelService sends certain events to it's RunLevelListener(s).</p><div class="section"><h3>The Inhabitant Sorter and Priority<a name="The_Inhabitant_Sorter_and_Priority"></a></h3><p>Earlier it was suggested that the start order of services in the same run level is non-deterministics. This is a partially true statement because the services were unrelated to one another. The &quot;real&quot; answer is as follows. The start order can be established within a given run level when either there is (a) an InhabitantActivator applied, or (b) the default inhabitant activator is used in conjunction with <a href="./hk2-api/apidocs/org/jvnet/hk2/annotations/Priority.html">Priority</a> annotation being applied to the service. Otherwise the start order can be assumed to be non-deterministic.</p><p>Callers can declare a service implementing the InhabitantActivator or apply the Priority annotations to affect the behavior of the default RunLevelService.</p></div><div class="section"><h3>The Inhabitant Activator<a name="The_Inhabitant_Activator"></a></h3><p>The InhabitantActivator service is another service that can be optionally declared in order to have the default RunlevelService delegate the actually instantiation/ activation during startup and also the release/deactivation during shutdown.</p></div><div class="section"><h3>The RunLevelListener<a name="The_RunLevelListener"></a></h3><p>The set of <a href="./auto-depends/apidocs/org/jvnet/hk2/component/RunLevelListener.html">RunLevelListener</a>s associated with the default RunLevelService will be notified of important events during it's operations. It is important to note that the default RunLevelService captures most Throwable types and sends them to the listeners - in general Exceptions are not emitted out to the caller of the default RunLevelService. The listeners are also notified of progress and cancellation events.</p><div class="section"><h4>Interruption<a name="Interruption"></a></h4><p>In the event the listener encounters a critical error and it is desirable for the operations of the default RunLevelService to be aborted, then an interrupt() could be called on the RunLevelService instance. The implementation is thread safe so that interrupt() can be called from the listener or by some other monitoring thread.</p></div><div class="section"><h4>AsyncPostConstruct<a name="AsyncPostConstruct"></a></h4><p>In some situations, a component / service acts in such a way that it spawns threads to complete other internal initialization operations. In such situations it is recommended that the service implements <a href="./hk2-api/apidocs/org/glassfish/hk2/AsyncPostConstruct.html">AsyncPostConstruct</a> instead of the standard PostConstruct contract. The default RunLevelService will wait for all asynchronous operations to complete at a given run level before attempting to continue the startup process proceeding to subsequent run levels.</p></div></div></div><div class="section"><h2>Extensions<a name="Extensions"></a></h2><p>As shown previously, run level scoping can be used useful for modeling life cycle of sub-systems. Here is an example of how run level scope can be declared on a service.</p><div class="source"><pre>@RunLevel(2, runLevelScope=MySubsystemScope.class)
@Service
public MySubsystemService implements MyContract {
}</pre></div><p>Here, MySubsystemService is now mapped to the MySubsystemScope run level scope. Note that it's perfectly fine to also declare meta-annotations for scoped run levels as well.</p><p>It is important to note that if you are using run level scoping extensions, you will also be responsible for implementing a <a href="./auto-depends/apidocs/org/jvnet/hk2/component/RunLevelService.html">RunLevelService</a> associated with your scope. Fortunately, HK2 provides an easy way to do this by extending the <a href="./auto-depends/apidocs/org/jvnet/hk2/component/AbstractRunLevelService.html">AbstractRunLevelService</a>.</p><div class="source"><pre>@Service(metadata=RunLevel.META_SCOPE_TAG + &quot;=...package-to...MySubsystemScope&quot;)
public class MySubsystemRunLevelService extends AbstractRunLevelService&lt;MySubsystemScope&gt; {
    public MySubsystemRunLevelService() {
        super(MySubsystemScope.class);
    }
}</pre></div><p>The RunLevel.META_SCOPE_TAG set in the metadata of the system is the important point to remember. The same approach for setting the metadata having RunLevel.META_SCOPE_TAG should also be used when creating custom activators, sorters, and listeners. Any instance of these types that are not annotated in this way will be assumed to belong to the default RunLevelService. The AbstractRunLevelService provides setters to override some of this default functionality - see the javadoc for details.</p></div><div class="section"><h2>Constraint Rules<a name="Constraint_Rules"></a></h2><p>RunLevel annotated services are different from normal services because they are governed by different life cycle rules. Imagine a situation where a non-RunLevel annotated service declares an injection point of a RunLevel annotated service.</p><div class="source"><pre>@Service
public StandardService {
  @Inject
  MyService4 myService4;
}

@RunLevel(2)
@Service
public MyService4 implements MyContract {
}</pre></div><p>If someone attempt to obtain (or be injected with) a StandardService, it is ambiguous whether or not the operation can be successful since it depends on the state of the default run level service. If the current run level is 0 then the StandardService cannot be instantiated because it needs a MyService4 instance that is not permitted to be created until run level value 2 is reached. Furthermore, assume that the run level is current at 3, and HK2 permitted the acquisition of StandardService injected with an instance of MyService4. Now, if partial shutdown occurs (i.e., proceedTo(1)) then the StandardService#myService4 instance becomes an orphan from the Habitat and may cause an error.</p><p>These issues are avoided by three semantical constraints placed on the use of RunLevel annotated services. These rules include:</p><ul><li>A standard, non-RunLevel annotated service can not be injected with a RunLevel annotated service.</li><li>A RunLevel annotated service with run level value N can not be injected with a RunLevel annotated service with value M when M &gt; N.</li><li>A RunLevel annotated service in run level scope X cannot be injected with a RunLevel annotated service in run level scope Y when X != Y.</li></ul><p><b>All rules are enforced at runtime.</b></p><p>There are two exceptions that are provided to bypass these constraint rules:</p><ul><li>Holder-style injection bypasses the normal constraint rules.<p>The Holder will act as a proxy to the service and be set to null when the service has not been activated, and a non-null value when it has been instantiated.</p><div class="source"><pre>@Service
public StandardService {
  @Inject
  Holder&lt;MyService4&gt; myService4Holder;
}

@RunLevel(2)
@Service
public MyService4 implements MyContract {
}</pre></div><p>It is important to note, however, that the service instance obtained from the Holder should never be cached or otherwise held unto for extended periods of time (i.e., not carried in a class field) since the run level annotated service can eventually be nulled when the run level service responsible for that service is shutting down. Also be careful to perform null checks at all times.</p></li><li>RunLevel(strict=false)<p>Declaring the run level with strict=false simply provides a means to create demand for the service when reaching the given run level. It will NOT, however, be managed / released as part of shutdown processing.</p><p>See the javadoc for additional details.</p></li></ul></div><div class="section"><h2>Conclusion<a name="Conclusion"></a></h2><p>The RunLevel annotation are appropriate when you need the system to automatically start your services. Typically, there is no need to add a RunLevel annotation to most services because Hk2 will automatically start your service when it is needed (i.e., by injection). In the event that you need the system to start your service, it is then important to consider which run level value to apply. This is usually determined by the other service dependencies you have as well as how other services depend on your new run level annotated service. In general, you want to use the highest run level value possible to allow startup to be as fast as possible. However, if there is another service that depends on your service, and that service has a run level of value=1 for instance, then your new service must be either value 0 or 1. The point is that other services that depend on your service must be of equal or higher run level value. So, a good rule of thumb is to use a run level value that equals the min(runLevel) of all dependencies to your service. If there are no other run level dependencies on your service, then pick the highest run level value applicable in your system.</p><p>In GlassFish, the Init, Startup, and PostStartup interfaces have been deprecated in favor of RunLevel annotations InitRunLevel, StartupRunLevel, and PostStartupRunLevel, respectively. These three run level meta annotations should be used whenever a component needs to be associated with startup automatic instantiation.</p></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">&#169;  
          2011
    
          Oracle Corporation
          
  

  
  
  &nbsp;| Last Published: 10/10/2011
  &nbsp;| Version: 1.6.22-SNAPSHOT
</div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
