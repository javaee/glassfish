<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">










<html>
  <head>
    <title></title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      </head>
  <body class="composite">
    <!-- TODO: move this into JavaScript to patch the skin
      <div class="xright">  </div>
    -->
    <div id="bodyColumn">
      <div id="contentBox">
        <div class="section"><h2>Introduction<a name="Introduction"></a></h2><p>A module is one to many jar files that can be treated as a unique entity within the module subsystem. Modules can have dependencies on other modules (including specific version requirements). Modules are defined by adding Manifest file information to a jar file that identify the module name, version etc...</p><ul><li>Modules should maintain a list of external dependencies (imports of other modules) in the manifest file describing the module. A module dependency is characterized by the imported module name, it&#x2019;s version (range) and if the imported module implementation can be shared with other modules.</li><li>Modules should have the ability to programmatically change their list of dependencies (imports) so they can choose particular version of imported modules depending on their execution environment.</li><li>Module subsystem should notify modules when the module is loaded, started or stopped. A module can only be loaded once within a class loader, however, it can be started and stopped multiple times. Modules which are not used are elected by the module subsystem for garbage collection. Once a module is garbage collected, the runtime will stop the module and then &#xfb02;ush its class loader. After this operation, the JVM will be in a state equivalent to the module never being loaded. If the module is re-loaded, it will use a new class loader, hence all static variable and initialization will need to be redone.</li><li>Module should have to capability of listening to events when other modules of interests are being loaded or unloaded.</li></ul></div><div class="section"><h2>Modules<a name="Modules"></a></h2><div class="section"><h3>Module Definition<a name="Module_Definition"></a></h3><p>At high level, a module is defined by the following information.</p><table border="1" class="bodyTable"><tr class="a"><td align="left">key</td><td align="left">description</td><td align="left">example</td></tr><tr class="b"><td align="left">name</td><td align="left">Name of the component</td><td align="left">com.sun.module</td></tr><tr class="a"><td align="left">version</td><td align="left">Version number of the module</td><td align="left">1.2.1-rc4</td></tr><tr class="b"><td align="left">imports</td><td align="left">list of imported component, comma separated</td><td align="left">com.sun.bar com.sun.myothermodule</td></tr><tr class="a"><td align="left">exports</td><td align="left">list of classes or packages exported</td><td align="left">com.sun.module.spi</td></tr></table><p>The module definition is represented by a <a href="#apidocscomsunenterprisemoduleModuleDefinition.html">ModuleDefinition</a> instance.</p><div class="section"><h4>ModuleDefinition.getName()<a name="ModuleDefinition.getName"></a></h4><p>The modules names are usually a package style name (com.sun.container.ejb) but can also be plain string. Dependencies are identified using the module&#x2019;s name so a unique name need to be chosen for each module.</p></div><div class="section"><h4>ModuleDefinition.getVersion()<a name="ModuleDefinition.getVersion"></a></h4><p>The format of a version is defined as</p><p>major.minor[.micro[_patch]][-qualifier]</p><p>where</p><ul><li>major, minor, micro and patch are non-negative integers.</li><li>patch indicate a patch release</li><li>qualifier is a string and can contain regular alphanumeric characters. It indicates a non FCS release (like snapshot) for the bundle.</li></ul></div><div class="section"><h4>Importing Modules<a name="Importing_Modules"></a></h4><p>A module dependency is represented by an instance of <a href="#apidocscomsunenterprisemoduleModuleDependency.html">ModuleDependecy</a>. A module definition has 0 to n dependencies accessible through the <a href="#apidocscomsunenterprisemoduleModuleDefinition.htmlgetDependencies">ModuleDefinition.getDependencies()</a> method. The ModuleDependency instance will define the following information :</p><p><b>Dependency Identification</b> Modules can declare their dependencies to other module by importing them. When importing a module, the definition must at least provide the imported module's name. If no version is provided, any implementation of the module&#x2019;s name will suffice. By default, imported modules are shared by its users. However, when importing a module, the importing module can restrict the imported module to a private usage.</p><p><b>Version range</b> When declaring a dependency on a module, exact version matching can quickly become difficult to maintain, therefore a version range can be used when importing a module.</p><p>Open Range matches any version greater than or equal to a specified version a+ // a.0 or later a.b+ // a.b or later a.b.c+ // a.b.c or later</p><p>Family range matches any version greater than or equal to a specific version in a particular family.</p><p>a* // a.* a.b.* // a.b.*</p><p>Question : Should we consider introducing Open Range within family ?</p><p><b>Re-exports</b> When importing a module, it is sometimes convenient to re-export the public interface of that module as part of the embedding module public interface, This sort of module composition can be very convenient when defining the concept of Container where the services offered are more than one module&#x2019;s public interface.</p><p><b>Private Module</b> can choose to use a private copy of a sub module, this could be useful to better control the sub module lifecycle.</p></div></div><div class="section"><h3>Module Packaging<a name="Module_Packaging"></a></h3><p>The definition of a module is read from its jar manifest. See <a class="externalLink" href="https://hk2.dev.java.net/source/browse/hk2/trunk/hk2/core/src/java/com/sun/enterprise/module/ManifestConstants.java?view=markup">this document</a> for what entries are defined and what the values can be.</p><p>Normally, the manifest entries are auto-generated by Maven's <tt>hk2-module</tt> packaging.</p></div></div><div class="section"><h2>Module Subsystem<a name="Module_Subsystem"></a></h2><div class="section"><h3>Module Instance<a name="Module_Instance"></a></h3><p>The module instance contains all information needed by the Registry and by the module subsystem to identify, store and server module users requests. The <a href="#apidocscomsunenterprisemoduleModule.html">Module</a> instance offers the following services :</p><ul><li>A module internal information like the state the module in the module subsystem, as well as if the module is shared or sticky (should never be stopped and unloaded).</li><li>A set of methods to get a ClassLoader instance to start loading any of the public interfaces as noted in the module definition.</li><li>A ModuleChangeListener registration/unregistration where listeners can be notified when the module has changed in the repository (new jar, new classes, etc...)</li></ul></div><div class="section"><h3>Initialization of Modules<a name="Initialization_of_Modules"></a></h3><p>The initialization of modules is done is several steps that can happen in rapid succession or spread over time. Each step in the module initialization translates into a <a href="#apidocscomsunenterprisemoduleModuleState.html">ModuleState</a>. The various steps and actions that will trigger passage from steps to steps is as follow :</p><ul><li><i>NEW</i> : the module instance has been constructed but not initialized. the module has been recognized by the module sub system and stored in the registry. However, no initialization is done, which mean that dependencies are not necessarily satisfied.</li><li><i>PREPARING</i> : the module instance is entering this phase when the module sub system is checking that all dependencies are satisfied. First, the ImportPolicy implementation (if any is defined in the manifest file) is loaded and the prepare method is called. After return the complete list of dependencies should be available on the <a href="#apidocscomsunenterprisemoduleModuleDefinition.htmlgetDependencies">ModuleDefinition.getDependencies()</a> method. For each element of this dependency list, the module sub system will resolve the dependency (which mean that sub-module will have to be in either the RESOLVED or READY. Once all dependencies are in either state, and all the module&#x2019;s resources returned by <a href="#apidocscomsunenterprisemoduleModuleDefinition.htmlgetLocations">ModuleDefinition.getLocations()</a> are available, the module state is switched to VALIDATING. </li></ul><ul><li><i>VALIDATING</i> : Validation is performed, ensure that all dependencies and versions are matching correctly. Once this is done, the module becomes RESOLVED.</li><li><i>RESOLVED</i> : Once a module is in resolved state, all classloaders have been set up correctly and exported interfaces are available. The module will load the LifecyclePolicy (if any defined in the manifest file) and will invoke the <a href="#apidocscomsunenterprisemoduleLifecyclePolicy.htmlstartcom.sun.enterprise.module.Module">LifecyclePolicy.start(Module)</a> method. The system will then send the <a href="#apidocscomsunenterprisemoduleModuleLifecycleListener.htmlmoduleStartedcom.sun.enterprise.module.Module">ModuleLifecycleListener.moduleStarted(Module)</a> events to all potential listener and finally switch the module to READY.</li><li><i>READY</i> : The module is ready to be used.</li></ul><p>At startup, all modules available in the local repository will be initialized and stored in the <a href="#apidocscomsunenterprisemoduleModulesRegistry.html">ModulesRegistry</a> with the module state NEW. As modules are being retrieved from the registry, the module sub system will begin the process of converting their states from new to ready. If any error occur while resolving a module, the <a href="#apidocscomsunenterprisemoduleResolveError.html">ResolveError</a> exception will be thrown and the module state will be switched to error.</p></div><div class="section"><h3>Module unloading<a name="Module_unloading"></a></h3><p>Module unloading is a tricky operation. It requires the following conditions to be met :</p><ul><li>The module should not be in the list of dependencies of any other module.</li><li>All instances of any class loaded by the private or public class loaders of the module must have been garbage collected.</li><li>The <a href="#apidocscomsunenterprisemoduleModule.htmlsetStickyboolean">Module.setSticky(boolean)</a> must return false</li></ul><p>Once these conditions are met, the module subsystem will begin the process of unloading the module. If a LifecyclePolicy was defined, the <a href="#apidocscomsunenterprisemoduleLifecyclePolicy.htmlstopcom.sun.enterprise.module.Module">LifecyclePolicy.stop()</a> method is called. Then any registered implementation of <a href="#apidocscomsunenterprisemoduleModuleLifecycleListener.html">ModuleLifecycleListener</a> on the registry will be notified with a <a href="#apidocscomsunenterprisemoduleModuleLifecycleListener.htmlmoduleStoppedcom.sun.enterprise.module.Module">ModuleLifecycleListener.moduleStopped(Module)</a> method call. Finally, the module instance will be removed from the registry and should be garbage collected. Strict monitoring of the module subsystem will ensure that modules are properly garbage collected as long lived instances and rogue references can impeach this process. The module subsystem will have the ability to unload automatically modules once the conditions above are met. As a module programmer or user, nothing particular need to be done outside of properly releasing instances and module references. Furthermore, it is impossible to programmatically release a module as it is solely dependent on the garbage collection mechanism.</p></div><div class="section"><h3>Modules and ClassLoaders<a name="Modules_and_ClassLoaders"></a></h3><p>In order to enforce module contracts, only public interfaces of a module should be visible to external users, this proposal rely on a ClassLoader facade. This facade class loader will not load class itself but will rather intercept all ClassLoader.loadClass() calls to see if the requested class is part of the published API or SPI. If it is, the call is then rerouted to the real classloader which will load both public and private classes. Ultimately, all classes are loaded by the private class loader, however, users of a module will only have access to the facade class loader restricting them into loading a public subset of the classes. Same rules should be applied to resources loading.</p></div></div><div class="section"><h2>Repository<a name="Repository"></a></h2><p>Modules repositories will allow the Module Subsystem to load modules from a centralized location. Repositories are implemented using the <a href="#apidocscomsunenterprisemoduleRepository.html">Repository</a> interface. Different implementations of this interface will handle different types of modules repositories. Each repository has a type (netbeans, osgi, jsr277), and APIs are in place to hide the actual implementation of the repository. These are the different types of repository we should offer at the minimum, combined with the ability to recognized different module types.</p><ul><li>Local installation</li><li>Embedded in Netbeans type of repository where some components (ant, jax-ws...) will need to be loaded from the Netbeans lib directory to avoid multiple packaging of the same technology</li><li>Maven 2 repository. As we should upgrade our current java.net maven repository to version 2 as well as the impact of moving the build system to use maven 2.</li><li>Dolphin (Java SE 7) will introduce repositories of modules, we will need to integrate those repositories as soon as Dolphin becomes available.</li></ul></div><div class="section"><h2>Module Registry<a name="Module_Registry"></a></h2><p>A module registry is a container for module instances. A module instance is the runtime equivalent of the module definition described above, there is one shared module instance per module definition but there can multiple private module instances for a single module definition. Each registry is associated with a single parenting class loader for all the module&#x2019;s classloader. This mean that all modules loaded by a particular instance of a registry will have the same parent classloader. The <a href="#apidocscomsunenterprisemoduleModulesRegistry.html">ModulesRegistry</a> will offer the following runtime services :</p><ul><li>Storing and retrieving of module instances.</li><li>Registration and unregistration of the <a href="#apidocscomsunenterprisemoduleModuleLifecycleListener.html">ModuleLifecycleListener</a> interface to listen to module startup/shutdown notifications.</li></ul></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">&#169;  
          2011
    
          Oracle Corporation
          
  

  
  
  &nbsp;| Last Published: 09/07/2011
  &nbsp;| Version: 1.6.18-SNAPSHOT
</div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
