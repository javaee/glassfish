<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">










<html>
  <head>
    <title></title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      </head>
  <body class="composite">
    <!-- TODO: move this into JavaScript to patch the skin
      <div class="xright">  </div>
    -->
    <div id="bodyColumn">
      <div id="contentBox">
        <div class="section"><h2>Introduction<a name="Introduction"></a></h2><p>With the HK2 module system, the module system is already responsible for instantiating many classes that constitute the application functionality.</p><p>HK2 components runtime will complement the module system so that it creates objects, but it configures such objects by:</p><ul><li>injecting other objects that are needed by a newly instantiated object.</li><li>injecting configuration information needed for that object.</li><li>making newly created objects available, so that it can be then injected to other objects that need it.</li></ul></div><div class="section"><h2>Services<a name="Services"></a></h2><p>HK2 relies on the notion of Service to identify the building blocks or the extension points of an application. Services are just POJO :</p><ul><li>implementing an interface</li><li>annotated with a <a href="./hk2-api/apidocs/org/jvnet/hk2/annotations/Contract.html">Contract</a> annotation</li><li>use the <a href="./hk2-api/index.html">hk2-api</a> DSL to declare components<p>To clearly separate the contract interface and its implementation, the HK2 runtime needs to understand what interfaces are contract and what implementations of such interfaces are services, so this call for an annotation describing interfaces as a service contract.</p><div class="source"><pre>@Retention(RUNTIME)
@Target(TYPE)
public @interface Contract {   
}</pre></div><p>Implementations of such contract should also be annotated with an annotation so the HK2 runtime can identify them as contracts implementations.</p><div class="source"><pre>@Retention(RUNTIME)
@Target(TYPE)
public @interface Service {
...
}</pre></div><p>see <a href="./auto-depends/apidocs/org/jvnet/hk2/annotations/Service.html">Service</a> for complete reference</p></li></ul><div class="section"><h3>Runtime<a name="Runtime"></a></h3><p>Once Services are defined, HK2 runtime can be used to instantiate or retrieve instances of services. Each service instance can be scoped to be Singleton, per thread, per application or custom. This allow for greater flexibility.</p><div class="section"><h4>Scopes<a name="Scopes"></a></h4><p>Scopes are services themselves, so they can be custom defined and added to the HK2 runtime before being used by other services. Each scope is responsible for storing the services instances which are tied to itself, therefore HK2 runtime does not rely on predefined scopes (although it comes with a few predefined ones).</p><div class="source"><pre>@Contract
public abstract class Scope {
    public abstract ScopeInstance current();
}</pre></div><p>Example of scoping for service to the predefined <a href="./hk2-api/apidocs/org/glassfish/hk2/scopes/Singleton.html">Singleton</a> Scope</p><div class="source"><pre>@Service
public Singleton implements Scope {
...
}

@Scope(Singleton.class)
@Service
public class SingletonService implements RandomContract {
...
}</pre></div><p>For the curious reader, you can experiment defining a new Scope implementation and have that scope used on your @Service implementations. You will see that the HK2 runtime use the Scope instance to store/retrieve services instances tied to that scope.</p></div><div class="section"><h4>Instantiation<a name="Instantiation"></a></h4><p>Instantiation of components</p><p>In the IoC world, components are not instantiated using a new () method call. Components are retrieved using the Services instance. The simplest way is to do that is through a getComponent(Class<i>T</i> contract) call although there are more APIs available at <a href="./hk2-api/org/glassfish/hk2/Services.html">Services</a></p><div class="source"><pre>    /**
     * Retrieve a service locator via a contract class.
     *
     * &lt;pre&gt;
     * // ExampleContract is an example of a contract type
     * &amp;#064;Contract
     * public interface ExampleContract {
     * }
     *
     * &amp;#064;Service
     * public class Example implements ExampleContract {
     * }
     * &lt;/pre&gt;
     *
     * @param contract the contract class
     * @return a contract locator
     */
    &lt;U&gt; ContractLocator&lt;U&gt; forContract(Class&lt;U&gt; contract);</pre></div><p>HK2 employs a &quot;lazy instantiation&quot; model. Only after demand exists for a component does that component get instantiated. Demand can come from either injection (@Inject) or through programmatic calls to the Services instances. Note, however, that the Scope of the service also plays a role on the instantiation of the given component.</p></div><div class="section"><h4>Lifecycle<a name="Lifecycle"></a></h4><p>Components can attach behaviors to their construction and destruction events by implementing the <a href="./hk2-api/apidocs/org/jvnet/hk2/component/PostConstruct.html">PostConstruct</a> and/or the <a href="./hk2-api/apidocs/org/jvnet/hk2/component/PreDestroy.html">PreDestroy</a> interfaces. Interfaces have been used rather than annotations for performance as it is faster to cast component instance to any of these interfaces to check if the component has implemented one of them rather than using reflection on all methods to find if they are annotated.</p><div class="section"><h5>Constructor Injection<a name="Constructor_Injection"></a></h5><p>It is possible to use Constructor injection by using the <a href="./hk2-api/apidocs/org/jvnet/hk2/annotations/Inject">Inject</a> annotation. This is particularly useful when using final variable to hold injected references.</p><div class="source"><pre>@Service
public class SomeService {

    final SomeContract dependencyOne;
    final SomeOtherContract dependencyTwo;

    public SomeService(@Inject(name=&quot;foo&quot;) SomeContract one, @Inject(name=&quot;bar&quot;) SomeOtherContract tow) {
        dependencyOne = one;
        dependencyTwo = two;
    }
}</pre></div></div></div></div><div class="section"><h3>Run Level Based Lifecycle<a name="Run_Level_Based_Lifecycle"></a></h3><p>Components can also use a <a href="./hk2-api/apidocs/org/jvnet/hk2/annotations/RunLevel">RunLevel</a> form of lifecycle. As stated previously, HK2 employs a &#x201c;lazy instantiation&#x201d; model for component creation. However, there are situations where the developer may want the instantiation to occur either immediately upon HK2 initialization or otherwise on some more regimented schedule.</p><p>see <a href="./runlevelservices.html">run level services</a> for complete reference</p></div></div><div class="section"><h2>Inversion of Control<a name="Inversion_of_Control"></a></h2><div class="section"><h3>Injection<a name="Injection"></a></h3><p>Services usually rely of other services to perform their tasks and the model described above can easily be extended to have the HK2 runtime identify the @Contract implementations required by a service. This call for a new annotation <a href="./hk2-api/apidocs/org/jvnet/hk2/annotations/Inject.html">Inject</a> which can be placed on fields or setter methods of any Service instantiated by the HK2 runtime and have that Service retrieved and injected during the service's instantiation by the component manager.</p><div class="source"><pre>Field :
@Inject
ConfigService config;

Setter method :
@Inject
public void set(ConfigService svc) {..}</pre></div><p>Injection can further qualify the intended injected service implementation by using a name and scope from which the service should be available.</p><div class="source"><pre>@Inject(Scope=Singleton.class, name=&quot;deploy&quot;)
AdminCommand deployCommand;</pre></div></div><div class="section"><h3>Instantiation Cascading<a name="Instantiation_Cascading"></a></h3><p>Injection of instances which have not been already instantiated triggers more instantiation. In a sense, you can see this as a components instantiation cascading where some code requests for a high level Service will in turn throuh @Inject annotation requires more injection/instantiation of lower level Services. This important feature is a great tool to keep the implementation as private as possible while relying on interfaces and separation of contract/providers.</p><p>Below is the example of how the instantiation of DeploymentService as a Startup contract implementation will trigger the instantiation of the ConfigService.</p><div class="source"><pre>@Contract
public interface Startup {...}

Iterable&lt;Startup&gt; startups;
startups = componentMgr.getComponents(Startup.class);

@Service
public class DeploymentService implements Startup {

    @Inject
    ConfigService config;
}

@Service
public Class ConfigService implements ... {...}
</pre></div></div></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">&#169;  
          2011
    
          Oracle Corporation
          
  

  
  
  &nbsp;| Last Published: 10/10/2011
  &nbsp;| Version: 1.6.22-SNAPSHOT
</div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
