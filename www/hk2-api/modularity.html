<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">










<html>
  <head>
    <title>Introduction to Modularity with HK2</title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      </head>
  <body class="composite">
    <!-- TODO: move this into JavaScript to patch the skin
      <div class="xright">  </div>
    -->
    <div id="bodyColumn">
      <div id="contentBox">
        <div class="section"><h2>Compatibility<a name="Compatibility"></a></h2><p>This page describes modularity with the HK2 2.0 API, which is based on the JSR-330 standard annotations. Also, Habitat has been replaced with a new interface called <a href="./apidocs/org/glassfish/hk2/api/ServiceLocator.html">ServiceLocator</a>. More information can be found <a href="./index.html">here</a>.</p></div><div class="section"><h2>Use cases<a name="Use_cases"></a></h2><p>Although people can use the layering of services instances offered by the <a href="./apidocs/org/glassfish/hk2/api/ServiceLocator.html">ServiceLocator</a> interface coupled with strict programmatic visibility, most installations use jar files as a way to distribute optional software parts to form a runtime environment.</p><p>When HK2 is started, a default <a href="./apidocs/org/glassfish/hk2/api/ServiceLocator.html">ServiceLocator</a> instance will be constructed. It will contain the union of all the <a href="./apidocs/org/jvnet/hk2/annotations/Contract.html">Contract</a> implementations it is told about. This default <a href="./apidocs/org/glassfish/hk2/api/ServiceLocator.html">ServiceLocator</a> will be used by HK2 to resolve dependencies indicated with <a class="externalLink" href="http://docs.oracle.com/javaee/6/api/javax/inject/Inject.html">@Inject</a>.</p><p>Therefore, the usual HK2 deployment is a flat name space where all the services are part of a single <a href="./apidocs/org/glassfish/hk2/api/ServiceLocator.html">ServiceLocator</a> instance. The name space will be populated with all the services declared in the configured hk2 jar files. The configured jar files can be a set of directories (repositories of modules) or can be added programmatically. When running in embedded mode HK2 uses the jars present on the classpath. In GlassFish all jars present in a special directory like ~glassfish/modules are used to configure the HK2 Runtime.</p><p>So you can see that by adding/removing hk2 jar from the original repository of modules, the set of services available for resolving dependencies can vary. This property can be used to deliver software with different capabilities by changing the set of modules delivered. Let's walk through a set of examples to clarify :</p><ul><li>Simple Substitution : a particular service implementation (capability) has a different implementation for each product.</li><li>Optional dependency : a particular service is available in certain products and may be missing in others.</li><li>Configuration driven dependencies : depending on the configuration of a product, a particular implementation of a service should be used.</li><li>Subclassing : a product implementation has one version, another version has a subclass of the first.</li></ul><div class="section"><h3>Simple substitution<a name="Simple_substitution"></a></h3><p>In this case, a particular version of a product is shipping one version of a Service while another version of the same product is shipping a different version. Please note that one implementation of that service must exist in any product. The first thing to do is to clarify very well the SPI this service implements, and define that SPI as an interface annotated with the <a href="./apidocs/org/jvnet/hk2/annotations/Contract.html">Contract</a> annotation.</p><div class="source"><pre>@Contract
public interface MyContract {

    /**
     * Document me well
     */
     void doSomething();
}</pre></div><p>Package this interface in a module that will be shipped with both products (let's call it services-api.jar).</p><div class="section"><h4>Service utilization<a name="Service_utilization"></a></h4><p>Whether code that wants to use the MyContract service resides in the common code to Product A or B, in the code specific to product A or B, it should have access to the service implementation using one the following technique</p><div class="section"><h5>Declarative Dependency<a name="Declarative_Dependency"></a></h5><p>By using the <a class="externalLink" href="http://docs.oracle.com/javaee/6/api/javax/inject/Inject.html">Inject</a> annotation, the code can declare to the system a requirement on a particular service implementation. Such declaration will force the HK2 dependency management subsystem to inject the resolved MyContract implementation in the instance variable.</p><div class="source"><pre>@Service
public class SomeUserCode {

    @Inject
    MyContract contractImpl;
}</pre></div><p>Another way is to use constructor injection :</p><div class="source"><pre>@Service
public class SomeUserCode {

    final MyContract contractImpl;

    @Inject
    SomeUserCode(MyContract impl) {
        this.contractImpl = impl;
    }
}</pre></div></div><div class="section"><h5>Explicit API lookup.<a name="Explicit_API_lookup."></a></h5><p>Provided the user's code has access to the <a href="./apidocs/org/glassfish/hk2/api/ServiceLocator.html">ServiceLocator</a> instance, it can do an explicit service lookup :</p><div class="source"><pre>    MyContract myContractImpl = serviceLocator.getService(MyContract.class);
    myContractImpl.doSomething();</pre></div></div></div><div class="section"><h4>Implementation Packaging<a name="Implementation_Packaging"></a></h4><p>In this simple substitution mode, the products will package at least one service or another but never the two of them. The simplest way of achieving that result is to define a productA-impl.jar and productB-impl.jar, each containing the service implementation and ensure that only one jar is shipped in the final product.</p></div></div><div class="section"><h3>Optional Dependency<a name="Optional_Dependency"></a></h3><p>In this mode, a service may be present or absent. It should be used when present but no failure should be generated by its absence.</p><div class="section"><h4>Optional declarative dependency<a name="Optional_declarative_dependency"></a></h4><div class="source"><pre>@Service
public class SomeUserCode {

    @Inject @Optional
    MyContract optionalContract = null;


    public void someMethod() {

        if (optionalContract!=null) {
            optionalContract.doSomething();
        }
    }
}
</pre></div></div><div class="section"><h4>Optional dependency API lookup<a name="Optional_dependency_API_lookup"></a></h4><p>Very similar to the previous case, the explicit lookup should just take into account that a null value can be returned.</p><div class="source"><pre>    MyContract myContractImpl = serviceLocator.getService(MyContract.class);
    if (myContractImpl!=null) {
        myContractImpl.doSomething();
    }</pre></div></div><div class="section"><h4>Packaging<a name="Packaging"></a></h4><p>Optional services should be packaged in a separate jar that does not contain any required services implementation or contract definitions.</p></div></div><div class="section"><h3>Config Based Dependency<a name="Config_Based_Dependency"></a></h3><p>Sometimes, several competing implementations of a service exist and some configuration should trigger which particular implementation should be use. These implementations need to be differentiated and that can be achieved by naming each implementation with a different name (String based) or using annotations (Type based).</p><div class="section"><h4>String based<a name="String_based"></a></h4><p>To add a string based name to a contract implementation, use the <a class="externalLink" href="http://docs.oracle.com/javaee/6/api/javax/inject/Named.html">Named</a> qualifier annotation.</p><div class="source"><pre>@Service @Named(&quot;foo&quot;)
public class MyContractImpl {

    public void doSomething() {

    }
}</pre></div><p>Another implementation can then name its implementation different.</p><div class="source"><pre>@Service @Named(&quot;bar&quot;)
public class MyContractImpl {

    public void doSomething() {

    }
}</pre></div><p>while to look up will need to use the HK2 APIs to do an explicit lookup.</p><div class="source"><pre>    String serviceName = ... get the service name from config/system property/code ...

    // hopefully service name is either &quot;foo&quot; or &quot;bar&quot;
    MyContract myContractImpl = serviceLocator.getService(MyContract.class, serviceName);
    // you should always check you got what you wanted.
    if (myContractImpl!=null) {
        myContractImpl.doSomething();
    }</pre></div></div><div class="section"><h4>Qualifier based<a name="Qualifier_based"></a></h4><p>More type safe but not always as flexible, services implementation can be disambiguated using qualifiers, which are special annotations that are themselves annotated with <a class="externalLink" href="http://docs.oracle.com/javaee/6/api/javax/inject/Qualifier.html">@Qualifier</a>.</p><div class="source"><pre>@Service
@Basic
public class MyContractImpl {

    public void doSomething() {

    }
}</pre></div><p>Another implementation can then name its implementation different.</p><div class="source"><pre>@Service
@Extended
public class MyContractImpl {

    public void doSomething() {

    }
}</pre></div><p>while to look up will need to use the HK2 APIs to do an explicit lookup, and instantiate an object by extending an <a href="./apidocs/org/glassfish/hk2/AnnotationLiteral.html">AnnotationLiteral</a>.</p><div class="source"><pre>    Annotation annotation = ... get it from config ...

    // hopefully service name is either &quot;foo&quot; or &quot;bar&quot;
    MyContract myContractImpl = serviceLocator.getService(MyContract.class, annotation);
    // you should always check you got what you wanted.
    if (myContractImpl!=null) {
        myContractImpl.doSomething();
    }</pre></div><p>of course, nothing prevents you from doing an injection based on a qualifier.</p><div class="source"><pre>    @Inject
    @Extended
    MyContract myContract;</pre></div></div></div><div class="section"><h3>Subclassing<a name="Subclassing"></a></h3><p>The casual reader might think that using the last methods (Substitution, Configuration) would work but it has major drawbacks. Let's look at an example.</p><div class="source"><pre>@Service @Named(&quot;super&quot;)
public class MyContractImpl {

    public void doSomething() {

    }
}

@Service @Named(&quot;child&quot;)
public class MyContract2Impl extends MyContractImpl {

    @Override
    public void doSomething() {
        super.doSomething();
        // do something else
    }
}</pre></div><p>The first issue is that it forces every client to know which environment it is operating in so it looks up the correct implementation using a hard-coded name. Instead we want the client code to be un-aware of the environment in which it is running.</p><p>You could try to do the substitution method but it does not work since you need the superclass definition in all cases (because of the subclassing).</p><p>The simplest solution to this problem is to introduce a level of indirection, adding an abstract class that contains all the common code while having 2 subclasses. The first subclass will be a tag class, probably empty that will declare the service for the first product. The other subclass will also be annotated with @Service and will contain the second product specific code.</p><div class="source"><pre>// note this class is NOT annotated with @Service
public abstract class AbstractMyContractImpl implements MyContract {
    public void doSomething() {
        ... interesting code ...
    }
}


@Service
public class MyContractImpl extends AbstractMyContractImpl {
}

@Service
public class MyContract2Impl extends AbstractMyContractImpl {

    @Override
    public void doSomething() {
        super.doSomething();
        // do something else
    }
}</pre></div><div class="section"><h4>Dependency declaration<a name="Dependency_declaration"></a></h4><p>The normal declarative or programmatic access to the implementation is similar to case 1, since only one of the two @Service annotated class will be shipped in a particular product.</p><div class="source"><pre>@Service
public class SomeUserCode {

    @Inject
    MyContract contractImpl;
}</pre></div></div></div><div class="section"><h3>Packaging<a name="Packaging"></a></h3><p>In order to meet the requirements of visibility, 3 modules are needed.</p><ul><li>common-impl.jar : will be packaging all common code to product A and B.</li><li>productA-impl.jar : contains the product A specific @Service classes (MyContractImpl.class in the example above).</li><li>productB-impl.jar : contains the product B spcecific @Service classes (MyContract2Impl above).</li></ul></div></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">&#169;  
          2012
    
          Oracle Corporation
          
  

  
  
  &nbsp;| Last Published: 07/14/2012
  &nbsp;| Version: 2.1.10-SNAPSHOT
</div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
